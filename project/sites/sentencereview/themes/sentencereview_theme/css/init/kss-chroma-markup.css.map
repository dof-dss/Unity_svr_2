{
	"version": 3,
	"file": "kss-chroma-markup.css",
	"sources": [
		"../../src/scss/init/kss-chroma-markup.scss",
		"../../src/scss/init/_index.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/_breakpoint.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/_settings.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/_context.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/_helpers.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/_parsers.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/_query.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/_single.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/single/_default.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/_double.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/double/_default-pair.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/double/_double-string.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/double/_default.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/_triple.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/triple/_default.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/_resolution.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/resolution/_resolution.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/_no-query.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/_respond-to.scss",
		"../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint/_legacy-settings.scss",
		"../../../../../../../node_modules/chroma-sass/sass/chroma/_functions.scss",
		"../../../../../../../node_modules/chroma-sass/sass/chroma/_variables.scss",
		"../../../../../../../node_modules/chroma-sass/sass/chroma/_internals.scss",
		"../../src/scss/init/_colors.scss",
		"../../src/scss/init/_variables.scss",
		"../../src/scss/init/_typography.scss",
		"../../../../../../../node_modules/chroma-sass/sass/_chroma.scss",
		"../../../../../../../node_modules/chroma-sass/sass/chroma/_skin.scss",
		"../../../../../../../node_modules/chroma-sass/sass/chroma/_kss.scss",
		"../../../../../../../node_modules/nicsdru_origins_theme/src/scss/init/compass-vr/_compass.scss",
		"../../../../../../../node_modules/nicsdru_origins_theme/src/scss/init/compass-vr/_vertical_rhythm.scss",
		"../../../../../../../node_modules/nicsdru_origins_theme/src/scss/init/compass-vr/_support.scss",
		"../../../../../../../node_modules/nicsdru_origins_theme/src/scss/init/compass-vr/_units.scss",
		"../../../../../../../node_modules/nicsdru_origins_theme/src/scss/init/helpers/_headings.scss",
		"../../../../../../../node_modules/nicsdru_origins_theme/src/scss/init/helpers/_strip-unit.scss",
		"../../../../../../../node_modules/nicsdru_origins_theme/src/scss/init/helpers/_type-checking.scss",
		"../../../../../../../node_modules/nicsdru_origins_theme/src/scss/init/visually-hidden/_visually-hidden.scss",
		"../../../../../../../node_modules/nicsdru_origins_theme/src/scss/init/responsive-typo/_resp-typo.scss",
		"../../../../../../../node_modules/nicsdru_unity_theme/src/scss/init/unity-layout/_unity-layout.scss"
	],
	"sourcesContent": [
		"// @file\n// This is a helper file to generate markup to the kss chroma.twig template.\n// The code is generated to a corresponding css file in the css directory and via a npm script is then cloned to the\n// the `chroma.twig` file in this directory. The css is specifically excluded from the the repo via `.gitignore`.\n@import 'index';\n/*\n#{chroma-kss-markup()}\n*/\n",
		"// Initialization partial\n//\n// To make it easier to use all variables and mixins in any Sass file in this\n// project, each .scss file has a `@import 'init';` declaration. The _init.scss\n// file is in charge of importing all the other partials needed for the\n// project.\n//\n// The initialization partial is organized in this way:\n// - First we set any shared Sass variables.\n// - Next we import Sass modules.\n// - Last we define our custom functions and mixins for this project.\n//\n// Weight: 10\n//\n// Style guide: init\n\n// The following Sass functions/mixins are required to generate some variables' values, so we load them first.\n@import '../../../../../../../../node_modules/breakpoint-sass/stylesheets/breakpoint';\n@import '../../../../../../../../node_modules/chroma-sass/sass/chroma/functions';\n\n@import 'colors';\n@import 'variables';\n@import 'typography';\n\n// 3rd party libraries\n//\n// The following sass modules are shared with all .scss files:\n// - [Breakpoint](http://breakpoint-sass.com/)\n// - [Chroma-sass](http://johnalbin.github.io/chroma/)\n// - [Compass vertical rhythm](http://compass-style.org/)\n// For compass we only load vertical rhythm support.\n// Note that this is loaded in standalone files that are developed for node sass further information can be found\n// @see https://github.com/Igosuki/compass-mixins\n//\n// Weight: -7\n//\n// Style guide: init.libraries\n\n// Add Chroma to manage colors.\n@import '../../../../../../../../node_modules/chroma-sass/sass/chroma';\n@import '../../../../../../../../node_modules/chroma-sass/sass/chroma/kss';\n@import '../../../../../../../../node_modules/nicsdru_origins_theme/src/scss/init/compass-vr/compass';\n\n// Functions\n//\n// Custom functions used on this site. Custom functions are generally used across a number of NICS Drupal themes,\n// therefore import these from the nicsdru_origins_theme via a node_module set up for that theme.\n//\n// Weight: -5\n//\n// Style guide: init.functions\n@import '../../../../../../../../node_modules/nicsdru_origins_theme/src/scss/init/helpers/headings';\n@import '../../../../../../../../node_modules/nicsdru_origins_theme/src/scss/init/helpers/strip-unit';\n@import '../../../../../../../../node_modules/nicsdru_origins_theme/src/scss/init/helpers/type-checking';\n\n// Mixins\n//\n// Custom mixins used on this site.\n//\n// Weight: -6\n//\n// Style guide: init.mixins\n@import '../../../../../../../../node_modules/nicsdru_origins_theme/src/scss/init/visually-hidden/visually-hidden';\n@import '../../../../../../../../node_modules/nicsdru_origins_theme/src/scss/init/responsive-typo/resp-typo';\n@import '../../../../../../../../node_modules/nicsdru_unity_theme/src/scss/init/unity-layout/unity-layout';\n",
		"//////////////////////////////\n// Default Variables\n//////////////////////////////\n$Breakpoint-Settings: (\n  'default media': all,\n  'default feature': min-width,\n  'default pair': width,\n\n  'force all media type': false,\n  'to ems': false,\n  'transform resolutions': true,\n\n  'no queries': false,\n  'no query fallbacks': false,\n\n  'base font size': 16px,\n\n  'legacy syntax': false\n);\n\n$breakpoint: () !default;\n\n//////////////////////////////\n// Imports\n//////////////////////////////\n@import \"breakpoint/settings\";\n@import 'breakpoint/context';\n@import 'breakpoint/helpers';\n@import 'breakpoint/parsers';\n@import 'breakpoint/no-query';\n\n@import 'breakpoint/respond-to';\n\n@import \"breakpoint/legacy-settings\";\n\n//////////////////////////////\n// Breakpoint Mixin\n//////////////////////////////\n\n@mixin breakpoint($query, $no-query: false) {\n  @include legacy-settings-warning;\n\n  // Reset contexts\n  @include private-breakpoint-reset-contexts();\n\n  $breakpoint: breakpoint($query, false);\n\n  $query-string: map-get($breakpoint, 'query');\n  $query-fallback: map-get($breakpoint, 'fallback');\n\n  $private-breakpoint-context-holder: map-get($breakpoint, 'context holder') !global;\n  $private-breakpoint-query-count: map-get($breakpoint, 'query count') !global;\n\n  // Allow for an as-needed override or usage of no query fallback.\n  @if $no-query != false {\n    $query-fallback: $no-query;\n  }\n\n  @if $query-fallback != false {\n    $context-setter: private-breakpoint-set-context('no-query', $query-fallback);\n  }\n\n  // Print Out Query String\n  @if not breakpoint-get('no queries') {\n    @media #{$query-string} {\n      @content;\n    }\n  }\n\n  @if breakpoint-get('no query fallbacks') != false or breakpoint-get('no queries') == true {\n\n    $type: type-of(breakpoint-get('no query fallbacks'));\n    $print: false;\n\n    @if ($type == 'bool') {\n      $print: true;\n    }\n    @else if ($type == 'string') {\n      @if $query-fallback == breakpoint-get('no query fallbacks') {\n        $print: true;\n      }\n    }\n    @else if ($type == 'list') {\n      @each $wrapper in breakpoint-get('no query fallbacks') {\n        @if $query-fallback == $wrapper {\n          $print: true;\n        }\n      }\n    }\n\n    // Write Fallback\n    @if ($query-fallback != false) and ($print == true) {\n      $type-fallback: type-of($query-fallback);\n\n      @if ($type-fallback != 'bool') {\n        #{$query-fallback} & {\n          @content;\n        }\n      }\n      @else {\n        @content;\n      }\n    }\n  }\n\n  @include private-breakpoint-reset-contexts();\n}\n\n\n@mixin mq($query, $no-query: false) {\n  @include breakpoint($query, $no-query) {\n    @content;\n  }\n}\n",
		"//////////////////////////////\n// Has Setting\n//////////////////////////////\n@function breakpoint-has($setting) {\n  @if map-has-key($breakpoint, $setting) {\n    @return true;\n  }\n  @else {\n    @return false;\n  }\n}\n\n//////////////////////////////\n// Get Settings\n//////////////////////////////\n@function breakpoint-get($setting) {\n  @if breakpoint-has($setting) {\n    @return map-get($breakpoint, $setting);\n  }\n  @else {\n    @return map-get($Breakpoint-Settings, $setting);\n  }\n}\n\n//////////////////////////////\n// Set Settings\n//////////////////////////////\n@function breakpoint-set($setting, $value) {\n  @if (str-index($setting, '-') or str-index($setting, '_')) and str-index($setting, ' ') == null {\n    @warn \"Words in Breakpoint settings should be separated by spaces, not dashes or underscores. Please replace dashes and underscores between words with spaces. Settings will not work as expected until changed.\";\n  }\n  $breakpoint: map-merge($breakpoint, ($setting: $value)) !global;\n  @return true;\n}\n\n@mixin breakpoint-change($setting, $value) {\n  $breakpoint-change: breakpoint-set($setting, $value);\n}\n\n@mixin breakpoint-set($setting, $value) {\n  @include breakpoint-change($setting, $value);\n}\n\n@mixin bkpt-change($setting, $value) {\n  @include breakpoint-change($setting, $value);\n}\n@mixin bkpt-set($setting, $value) {\n  @include breakpoint-change($setting, $value);\n}\n\n//////////////////////////////\n// Remove Setting\n//////////////////////////////\n@function breakpoint-reset($settings...) {\n  @if length($settings) == 1 {\n    $settings: nth($settings, 1);\n  }\n\n  @each $setting in $settings {\n    $breakpoint: map-remove($breakpoint, $setting) !global;\n  }\n  @return true;\n}\n\n@mixin breakpoint-reset($settings...) {\n  $breakpoint-reset: breakpoint-reset($settings);\n}\n\n@mixin bkpt-reset($settings...) {\n  $breakpoint-reset: breakpoint-reset($settings);\n}",
		"//////////////////////////////\n// Private Breakpoint Variables\n//////////////////////////////\n$private-breakpoint-context-holder: ();\n$private-breakpoint-query-count: 0 !default;\n\n//////////////////////////////\n// Breakpoint Has Context\n// Returns whether or not you are inside a Breakpoint query\n//////////////////////////////\n@function breakpoint-has-context() {\n  @if length($private-breakpoint-query-count) {\n    @return true;\n  }\n  @else {\n    @return false;\n  }\n}\n\n//////////////////////////////\n// Breakpoint Get Context\n// $feature: Input feature to get it's current MQ context. Returns false if no context\n//////////////////////////////\n@function breakpoint-get-context($feature) {\n  @if map-has-key($private-breakpoint-context-holder, $feature) {\n    $get: map-get($private-breakpoint-context-holder, $feature);\n    // Special handling of no-query from get side so /false/ prepends aren't returned\n    @if $feature == 'no-query' {\n      @if type-of($get) == 'list' and length($get) > 1 and nth($get, 1) == false {\n        $get: nth($get, length($get));\n      }\n    }\n    @return $get;\n  }\n  @else {\n    @if breakpoint-has-context() and $feature == 'media' {\n      @return breakpoint-get('default media');\n    }\n    @else {\n      @return false;\n    }\n  }\n}\n\n//////////////////////////////\n// Private function to set context\n//////////////////////////////\n@function private-breakpoint-set-context($feature, $value) {\n  @if $value == 'monochrome' {\n    $feature: 'monochrome';\n  }\n\n  $current: map-get($private-breakpoint-context-holder, $feature);\n  @if $current and length($current) == $private-breakpoint-query-count {\n    @warn \"You have already queried against `#{$feature}`. Unexpected things may happen if you query against the same feature more than once in the same `and` query. Breakpoint is overwriting the current context with `#{$value}`\";\n  }\n\n  @if not map-has-key($private-breakpoint-context-holder, $feature) {\n    $v-holder: ();\n    @for $i from 1 to $private-breakpoint-query-count {\n      @if $feature == 'media' {\n        $v-holder: append($v-holder, breakpoint-get('default media'));\n      }\n      @else {\n        $v-holder: append($v-holder, false);\n      }\n    }\n    $v-holder: append($v-holder, $value);\n    $private-breakpoint-context-holder: map-merge($private-breakpoint-context-holder, ($feature: $v-holder)) !global;\n  }\n  @else {\n    $v-holder: map-get($private-breakpoint-context-holder, $feature);\n    $length: length($v-holder);\n    @for $i from $length to $private-breakpoint-query-count - 1 {\n      @if $feature == 'media' {\n        $v-holder: append($v-holder, breakpoint-get('default media'));\n      }\n      @else {\n        $v-holder: append($v-holder, false);\n      }\n    }\n    $v-holder: append($v-holder, $value);\n    $private-breakpoint-context-holder: map-merge($private-breakpoint-context-holder, ($feature: $v-holder)) !global;\n  }\n\n  @return true;\n}\n\n//////////////////////////////\n// Private function to reset context\n//////////////////////////////\n@mixin private-breakpoint-reset-contexts {\n  $private-breakpoint-context-holder: () !global;\n  $private-breakpoint-query-count: 0 !global;\n}",
		"//////////////////////////////\n// Converts the input value to Base EMs\n//////////////////////////////\n@function breakpoint-to-base-em($value) {\n  $value-unit: unit($value);\n\n  // Will convert relative EMs into root EMs.\n  @if breakpoint-get('base font size') and type-of(breakpoint-get('base font size')) == 'number' and $value-unit == 'em' {\n    $base-unit: unit(breakpoint-get('base font size'));\n\n    @if $base-unit == 'px' or $base-unit == '%' or $base-unit == 'em' or $base-unit == 'pt' {\n      @return base-conversion($value) / base-conversion(breakpoint-get('base font size')) * 1em;\n    }\n    @else {\n      @warn '#{breakpoint-get(\\'base font size\\')} is not set in valid units for font size!';\n      @return false;\n    }\n  }\n  @else {\n    @return base-conversion($value);\n  }\n}\n\n@function base-conversion($value) {\n  $unit: unit($value);\n\n  @if $unit == 'px' {\n    @return $value / 16px * 1em;\n  }\n  @else if $unit == '%' {\n    @return $value / 100% * 1em;\n  }\n  @else if $unit == 'em' {\n    @return $value;\n  }\n  @else if $unit == 'pt' {\n    @return $value / 12pt * 1em;\n  }\n  @else {\n    @return $value;\n//    @warn 'Everything is terrible! What have you done?!';\n  }\n}\n\n//////////////////////////////\n// Returns whether the feature can have a min/max pair\n//////////////////////////////\n$breakpoint-min-max-features: 'color',\n                              'color-index',\n                              'aspect-ratio',\n                              'device-aspect-ratio',\n                              'device-height',\n                              'device-width',\n                              'height',\n                              'monochrome',\n                              'resolution',\n                              'width';\n\n@function breakpoint-min-max($feature) {\n  @each $item in $breakpoint-min-max-features {\n    @if $feature == $item {\n      @return true;\n    }\n  }\n  @return false;\n}\n\n//////////////////////////////\n// Returns whether the feature can have a string value\n//////////////////////////////\n$breakpoint-string-features:  'orientation',\n                              'scan',\n                              'color',\n                              'aspect-ratio',\n                              'device-aspect-ratio',\n                              'pointer',\n                              'luminosity';\n\n@function breakpoint-string-value($feature) {\n  @each $item in $breakpoint-string-features {\n    @if breakpoint-min-max($item) {\n      @if $feature == 'min-#{$item}' or $feature == 'max-#{$item}' {\n        @return true;\n      }\n    }\n    @else if $feature == $item {\n      @return true;\n    }\n  }\n  @return false;\n}\n\n//////////////////////////////\n// Returns whether the feature is a media type\n//////////////////////////////\n$breakpoint-media-types:  'all',\n                          'braille',\n                          'embossed',\n                          'handheld',\n                          'print',\n                          'projection',\n                          'screen',\n                          'speech',\n                          'tty',\n                          'tv';\n\n@function breakpoint-is-media($feature) {\n  @each $media in $breakpoint-media-types {\n    @if ($feature == $media) or ($feature == 'not #{$media}') or ($feature == 'only #{$media}') {\n      @return true;\n    }\n  }\n\n  @return false;\n}\n\n//////////////////////////////\n// Returns whether the feature can stand alone\n//////////////////////////////\n$breakpoint-single-string-features: 'color',\n                                    'color-index',\n                                    'grid',\n                                    'monochrome';\n\n@function breakpoint-single-string($feature) {\n  @each $item in $breakpoint-single-string-features {\n    @if $feature == $item {\n      @return true;\n    }\n  }\n  @return false;\n}\n\n//////////////////////////////\n// Returns whether the feature\n//////////////////////////////\n@function breakpoint-is-resolution($feature) {\n  $resolutions: 'device-pixel-ratio', 'dpr';\n\n  @if breakpoint-get('transform resolutions') {\n    $resolutions: append($resolutions, 'resolution');\n  }\n\n  @each $reso in $resolutions {\n    @if index($feature, $reso) or index($feature, 'min-#{$reso}') or index($feature, 'max-#{$reso}') {\n      @return true;\n    }\n  }\n\n  @return false;\n}\n",
		"//////////////////////////////\n// Import Parser Pieces\n//////////////////////////////\n@import \"parsers/query\";\n@import \"parsers/single\";\n@import \"parsers/double\";\n@import \"parsers/triple\";\n@import \"parsers/resolution\";\n\n$Memo-Exists: function-exists(memo-get) and function-exists(memo-set);\n\n//////////////////////////////\n// Breakpoint Function\n//////////////////////////////\n@function breakpoint($query, $contexts...) {\n  $run: true;\n  $return: ();\n\n  // Grab the Memo Output if Memoization can be a thing\n  @if $Memo-Exists {\n    $return: memo-get(breakpoint, breakpoint $query $contexts);\n\n    @if $return != null {\n      $run: false;\n    }\n  }\n\n  @if not $Memo-Exists or $run {\n    // Internal Variables\n    $query-string: '';\n    $query-fallback: false;\n    $return: ();\n\n    // Reserve Global Private Breakpoint Context\n    $holder-context: $private-breakpoint-context-holder;\n    $holder-query-count: $private-breakpoint-query-count;\n\n    // Reset Global Private Breakpoint Context\n    $private-breakpoint-context-holder: () !global;\n    $private-breakpoint-query-count: 0 !global;\n\n\n    // Test to see if it's a comma-separated list\n    $or-list: if(list-separator($query) == 'comma', true, false);\n\n\n    @if ($or-list == false and breakpoint-get('legacy syntax') == false) {\n      $query-string: breakpoint-parse($query);\n    }\n    @else {\n      $length: length($query);\n\n      $last: nth($query, $length);\n      $query-fallback: breakpoint-no-query($last);\n\n      @if ($query-fallback != false) {\n        $length: $length - 1;\n      }\n\n      @if (breakpoint-get('legacy syntax') == true) {\n        $mq: ();\n\n        @for $i from 1 through $length {\n          $mq: append($mq, nth($query, $i), comma);\n        }\n\n        $query-string: breakpoint-parse($mq);\n      }\n      @else {\n        $query-string: '';\n        @for $i from 1 through $length {\n          $query-string: $query-string + if($i == 1, '', ', ') + breakpoint-parse(nth($query, $i));\n        }\n      }\n    }\n\n    $return: ('query': $query-string,\n        'fallback': $query-fallback,\n        'context holder': $private-breakpoint-context-holder,\n        'query count': $private-breakpoint-query-count\n    );\n    @if length($contexts) > 0 and nth($contexts, 1) != false {\n      @if $query-fallback != false {\n        $context-setter: private-breakpoint-set-context('no-query', $query-fallback);\n      }\n      $context-map: ();\n      @each $context in $contexts {\n        $context-map: map-merge($context-map, ($context: breakpoint-get-context($context)));\n      }\n      $return: map-merge($return, (context: $context-map));\n    }\n\n    // Reset Global Private Breakpoint Context\n    $private-breakpoint-context-holder: () !global;\n    $private-breakpoint-query-count: 0 !global;\n\n    @if $Memo-Exists {\n      $holder: memo-set(breakpoint, breakpoint $query $contexts, $return);\n    }\n  }\n\n  @return $return;\n}\n\n//////////////////////////////\n// General Breakpoint Parser\n//////////////////////////////\n@function breakpoint-parse($query) {\n  // Increase number of 'and' queries\n  $private-breakpoint-query-count: $private-breakpoint-query-count + 1 !global;\n\n  // Set up Media Type\n  $query-print: '';\n\n  $force-all: ((breakpoint-get('force all media type') == true) and (breakpoint-get('default media') == 'all'));\n  $empty-media: true;\n  @if ($force-all == true) or (breakpoint-get('default media') != 'all') {\n    // Force the print of the default media type if (force all is true and default media type is all) or (default media type is not all)\n    $query-print: breakpoint-get('default media');\n    $empty-media: false;\n  }\n\n\n  $query-resolution: false;\n\n  $query-holder: breakpoint-parse-query($query);\n\n\n\n  // Loop over each parsed out query and write it to $query-print\n  $first: true;\n\n  @each $feature in $query-holder {\n    $length: length($feature);\n\n    // Parse a single feature\n    @if ($length == 1) {\n      // Feature is currently a list, grab the actual value\n      $feature: nth($feature, 1);\n\n      // Media Type must by convention be the first item, so it's safe to flat override $query-print, which right now should only be the default media type\n      @if (breakpoint-is-media($feature)) {\n        @if ($force-all == true) or ($feature != 'all') {\n          // Force the print of the default media type if (force all is true and default media type is all) or (default media type is not all)\n          $query-print: $feature;\n          $empty-media: false;\n\n          // Set Context\n          $context-setter: private-breakpoint-set-context(media, $query-print);\n        }\n      }\n      @else {\n        $parsed: breakpoint-parse-single($feature, $empty-media, $first);\n        $query-print: '#{$query-print} #{$parsed}';\n        $first: false;\n      }\n    }\n    // Parse a double feature\n    @else if ($length == 2) {\n      @if (breakpoint-is-resolution($feature) != false) {\n        $query-resolution: $feature;\n      }\n      @else {\n        $parsed: null;\n        // If it's a string/number pair,\n        // we check to see if one is a single-string value,\n        // then we parse it as a normal double\n        $alpha: nth($feature, 1);\n        $beta: nth($feature, 2);\n        @if breakpoint-single-string($alpha) or breakpoint-single-string($beta) {\n          $parsed: breakpoint-parse-single($alpha, $empty-media, $first);\n          $query-print: '#{$query-print} #{$parsed}';\n          $first: false;\n          $parsed: breakpoint-parse-single($beta, $empty-media, $first);\n          $query-print: '#{$query-print} #{$parsed}';\n        }\n        @else {\n          $parsed: breakpoint-parse-double($feature, $empty-media, $first);\n          $query-print: '#{$query-print} #{$parsed}';\n          $first: false;\n        }\n      }\n    }\n    // Parse a triple feature\n    @else if ($length == 3) {\n      $parsed: breakpoint-parse-triple($feature, $empty-media, $first);\n      $query-print: '#{$query-print} #{$parsed}';\n      $first: false;\n    }\n\n  }\n\n  @if ($query-resolution != false) {\n    $query-print: breakpoint-build-resolution($query-print, $query-resolution, $empty-media, $first);\n  }\n\n  // Loop through each feature that's been detected so far and append 'false' to the the value list to increment their counters\n  @each $f, $v in $private-breakpoint-context-holder {\n    $v-holder: $v;\n    $length: length($v-holder);\n    @if length($v-holder) < $private-breakpoint-query-count {\n      @for $i from $length to $private-breakpoint-query-count {\n        @if $f == 'media' {\n          $v-holder: append($v-holder, breakpoint-get('default media'));\n        }\n        @else {\n          $v-holder: append($v-holder, false);\n        }\n      }\n    }\n    $private-breakpoint-context-holder: map-merge($private-breakpoint-context-holder, ($f: $v-holder)) !global;\n  }\n\n  @return $query-print;\n}\n",
		"@function breakpoint-parse-query($query) {\n  // Parse features out of an individual query\n  $feature-holder: ();\n  $query-holder: ();\n  $length: length($query);\n\n  @if $length == 2 {\n    // If we've got a string/number, number/string, check to see if it's a valid string/number pair or two singles\n    @if (type-of(nth($query, 1)) == 'string' and type-of(nth($query, 2)) == 'number') or (type-of(nth($query, 1)) == 'number' and type-of(nth($query, 2)) == 'string') {\n\n      $number: '';\n      $value: '';\n\n      @if type-of(nth($query, 1)) == 'string' {\n        $number: nth($query, 2);\n        $value: nth($query, 1);\n      }\n      @else {\n        $number: nth($query, 1);\n        $value: nth($query, 2);\n      }\n\n      // If the string value can be a single value, check to see if the number passed in is a valid input for said single value. Fortunately, all current single-value options only accept unitless numbers, so this check is easy.\n      @if breakpoint-single-string($value) {\n        @if unitless($number) {\n          $feature-holder: append($value, $number, space);\n          $query-holder: append($query-holder, $feature-holder, comma);\n          @return $query-holder;\n        }\n      }\n      // If the string is a media type, split the query\n      @if breakpoint-is-media($value) {\n        $query-holder: append($query-holder, nth($query, 1));\n        $query-holder: append($query-holder, nth($query, 2));\n        @return $query-holder;\n      }\n      // If it's not a single feature, we're just going to assume it's a proper string/value pair, and roll with it.\n      @else {\n        $feature-holder: append($value, $number, space);\n        $query-holder: append($query-holder, $feature-holder, comma);\n        @return $query-holder;\n      }\n\n    }\n    // If they're both numbers, we assume it's a double and roll with that\n    @else if (type-of(nth($query, 1)) == 'number' and type-of(nth($query, 2)) == 'number') {\n      $feature-holder: append(nth($query, 1), nth($query, 2), space);\n      $query-holder: append($query-holder, $feature-holder, comma);\n      @return $query-holder;\n    }\n    // If they're both strings and neither are singles, we roll with that.\n    @else if (type-of(nth($query, 1)) == 'string' and type-of(nth($query, 2)) == 'string') {\n      @if not breakpoint-single-string(nth($query, 1)) and not breakpoint-single-string(nth($query, 2)) {\n        $feature-holder: append(nth($query, 1), nth($query, 2), space);\n        $query-holder: append($query-holder, $feature-holder, comma);\n        @return $query-holder;\n      }\n    }\n  }\n  @else if $length == 3 {\n    // If we've got three items and none is a list, we check to see\n    @if type-of(nth($query, 1)) != 'list' and type-of(nth($query, 2)) != 'list' and type-of(nth($query, 3)) != 'list' {\n      // If none of the items are single string values and none of the values are media values, we're good.\n      @if (not breakpoint-single-string(nth($query, 1)) and not breakpoint-single-string(nth($query, 2)) and not breakpoint-single-string(nth($query, 3))) and  ((not breakpoint-is-media(nth($query, 1)) and not breakpoint-is-media(nth($query, 2)) and not breakpoint-is-media(nth($query, 3)))) {\n        $feature-holder: append(nth($query, 1), nth($query, 2), space);\n        $feature-holder: append($feature-holder, nth($query, 3), space);\n        $query-holder: append($query-holder, $feature-holder, comma);\n        @return $query-holder;\n      }\n      // let's check to see if the first item is a media type\n      @else if breakpoint-is-media(nth($query, 1)) {\n        $query-holder: append($query-holder, nth($query, 1));\n        $feature-holder: append(nth($query, 2), nth($query, 3), space);\n        $query-holder: append($query-holder, $feature-holder);\n        @return $query-holder;\n      }\n    }\n  }\n\n  // If it's a single item, or if it's not a special case double or triple, we can simply return the query.\n  @return $query;\n}\n",
		"//////////////////////////////\n// Import Pieces\n//////////////////////////////\n@import \"single/default\";\n\n@function breakpoint-parse-single($feature, $empty-media, $first) {\n  $parsed: '';\n  $leader: '';\n  // If we're forcing\n  @if not ($empty-media) or not ($first) {\n    $leader: 'and ';\n  }\n\n  // If it's a single feature that can stand alone, we let it\n  @if (breakpoint-single-string($feature)) {\n    $parsed: $feature;\n    // Set Context\n    $context-setter: private-breakpoint-set-context($feature, $feature);\n  }\n  // If it's not a stand alone feature, we pass it off to the default handler.\n  @else {\n    $parsed: breakpoint-parse-default($feature);\n  }\n\n  @return $leader + '(' + $parsed + ')';\n}\n",
		"@function breakpoint-parse-default($feature) {\n  $default: breakpoint-get('default feature');\n\n  // Set Context\n  $context-setter: private-breakpoint-set-context($default, $feature);\n\n  @if (breakpoint-get('to ems') == true) and (type-of($feature) == 'number') {\n    @return '#{$default}: #{breakpoint-to-base-em($feature)}';\n  }\n  @else {\n    @return '#{$default}: #{$feature}';\n  }\n}\n",
		"//////////////////////////////\n// Import Pieces\n//////////////////////////////\n@import \"double/default-pair\";\n@import \"double/double-string\";\n@import \"double/default\";\n\n@function breakpoint-parse-double($feature, $empty-media, $first) {\n  $parsed: '';\n  $leader: '';\n  // If we're forcing\n  @if not ($empty-media) or not ($first) {\n    $leader: 'and ';\n  }\n\n  $first: nth($feature, 1);\n  $second: nth($feature, 2);\n\n  // If we've got two numbers, we know we need to use the default pair because there are no media queries that has a media feature that is a number\n  @if type-of($first) == 'number' and type-of($second) == 'number' {\n    $parsed: breakpoint-parse-default-pair($first, $second);\n  }\n  // If they are both strings, we send it through the string parser\n  @else if type-of($first) == 'string' and type-of($second) == 'string' {\n    $parsed: breakpoint-parse-double-string($first, $second);\n  }\n  // If it's a string/number pair, we parse it as a normal double\n  @else {\n    $parsed: breakpoint-parse-double-default($first, $second);\n  }\n\n  @return $leader + $parsed;\n}\n",
		"@function breakpoint-parse-default-pair($first, $second) {\n  $default: breakpoint-get('default pair');\n  $min: '';\n  $max: '';\n\n  // Sort into min and max\n  $min: min($first, $second);\n  $max: max($first, $second);\n\n  // Set Context\n  $context-setter: private-breakpoint-set-context(min-#{$default}, $min);\n  $context-setter: private-breakpoint-set-context(max-#{$default}, $max);\n\n  // Make them EMs if need be\n  @if (breakpoint-get('to ems') == true) {\n    $min: breakpoint-to-base-em($min);\n    $max: breakpoint-to-base-em($max);\n  }\n\n  @return '(min-#{$default}: #{$min}) and (max-#{$default}: #{$max})';\n}\n",
		"@function breakpoint-parse-double-string($first, $second) {\n  $feature: '';\n  $value: '';\n\n  // Test to see which is the feature and which is the value\n  @if (breakpoint-string-value($first) == true) {\n    $feature: $first;\n    $value: $second;\n  }\n  @else if (breakpoint-string-value($second) == true) {\n    $feature: $second;\n    $value: $first;\n  }\n  @else {\n    @warn \"Neither #{$first} nor #{$second} is a valid media query name.\";\n  }\n\n  // Set Context\n  $context-setter: private-breakpoint-set-context($feature, $value);\n\n  @return '(#{$feature}: #{$value})';\n}",
		"@function breakpoint-parse-double-default($first, $second) {\n  $feature: '';\n  $value: '';\n\n  @if type-of($first) == 'string' {\n    $feature: $first;\n    $value: $second;\n  }\n  @else {\n    $feature: $second;\n    $value: $first;\n  }\n\n  // Set Context\n  $context-setter: private-breakpoint-set-context($feature, $value);\n\n  @if (breakpoint-get('to ems') == true) {\n    $value: breakpoint-to-base-em($value);\n  }\n\n  @return '(#{$feature}: #{$value})'\n}\n",
		"//////////////////////////////\n// Import Pieces\n//////////////////////////////\n@import \"triple/default\";\n\n@function breakpoint-parse-triple($feature, $empty-media, $first) {\n  $parsed: '';\n  $leader: '';\n\n  // If we're forcing\n  @if not ($empty-media) or not ($first) {\n    $leader: 'and ';\n  }\n\n  // separate the string features from the value numbers\n  $string: null;\n  $numbers: null;\n  @each $val in $feature {\n    @if type-of($val) == string {\n      $string: $val;\n    }\n    @else {\n      @if type-of($numbers) == 'null' {\n        $numbers: $val;\n      }\n      @else {\n        $numbers: append($numbers, $val);\n      }\n    }\n  }\n\n  $parsed: breakpoint-parse-triple-default($string, nth($numbers, 1), nth($numbers, 2));\n\n  @return $leader + $parsed;\n\n}\n",
		"@function breakpoint-parse-triple-default($feature, $first, $second) {\n\n  // Sort into min and max\n  $min: min($first, $second);\n  $max: max($first, $second);\n\n  // Set Context\n  $context-setter: private-breakpoint-set-context(min-#{$feature}, $min);\n  $context-setter: private-breakpoint-set-context(max-#{$feature}, $max);\n\n  // Make them EMs if need be\n  @if (breakpoint-get('to ems') == true) {\n    $min: breakpoint-to-base-em($min);\n    $max: breakpoint-to-base-em($max);\n  }\n\n  @return '(min-#{$feature}: #{$min}) and (max-#{$feature}: #{$max})';\n}\n",
		"@import \"resolution/resolution\";\n\n@function breakpoint-build-resolution($query-print, $query-resolution, $empty-media, $first) {\n  $leader: '';\n  // If we're forcing\n  @if not ($empty-media) or not ($first) {\n    $leader: 'and ';\n  }\n\n  @if breakpoint-get('transform resolutions') and $query-resolution {\n    $resolutions: breakpoint-make-resolutions($query-resolution);\n    $length: length($resolutions);\n    $query-holder: '';\n\n    @for $i from 1 through $length {\n      $query: '#{$query-print} #{$leader}#{nth($resolutions, $i)}';\n      @if $i == 1 {\n        $query-holder: $query;\n      }\n      @else {\n        $query-holder: '#{$query-holder}, #{$query}';\n      }\n    }\n\n    @return $query-holder;\n  }\n  @else {\n    // Return with attached resolution\n    @return $query-print;\n  }\n}\n",
		"@function breakpoint-make-resolutions($resolution) {\n  $length: length($resolution);\n\n  $output: ();\n\n  @if $length == 2 {\n    $feature: '';\n    $value: '';\n\n    // Find which is number\n    @if type-of(nth($resolution, 1)) == 'number' {\n      $value: nth($resolution, 1);\n    }\n    @else {\n      $value: nth($resolution, 2);\n    }\n\n    // Determine min/max/standard\n    @if index($resolution, 'min-resolution') {\n      $feature: 'min-';\n    }\n    @else if index($resolution, 'max-resolution') {\n      $feature: 'max-';\n    }\n\n    $standard: '(#{$feature}resolution: #{$value})';\n\n    // If we're not dealing with dppx,\n    @if unit($value) != 'dppx' {\n      $base: 96dpi;\n      @if unit($value) == 'dpcm' {\n        $base: 243.84dpcm;\n      }\n      // Write out feature tests\n      $webkit: '';\n      $moz: '';\n      $webkit: '(-webkit-#{$feature}device-pixel-ratio: #{$value / $base})';\n      $moz: '(#{$feature}-moz-device-pixel-ratio: #{$value / $base})';\n      // Append to output\n      $output: append($output, $standard, space);\n      $output: append($output, $webkit, space);\n      $output: append($output, $moz, space);\n    }\n    @else {\n      $webkit: '';\n      $moz: '';\n      $webkit: '(-webkit-#{$feature}device-pixel-ratio: #{$value / 1dppx})';\n      $moz: '(#{$feature}-moz-device-pixel-ratio: #{$value / 1dppx})';\n      $fallback: '(#{$feature}resolution: #{$value / 1dppx * 96dpi})';\n      // Append to output\n      $output: append($output, $standard, space);\n      $output: append($output, $webkit, space);\n      $output: append($output, $moz, space);\n      $output: append($output, $fallback, space);\n    }\n\n  }\n\n  @return $output;\n}\n",
		"@function breakpoint-no-query($query) {\n  @if type-of($query) == 'list' {\n    $keyword: nth($query, 1);\n\n    @if type-of($keyword) == 'string' and ($keyword == 'no-query' or $keyword == 'no query' or $keyword == 'fallback') {\n      @return nth($query, 2);\n    }\n    @else {\n      @return false;\n    }\n  }\n  @else {\n    @return false;\n  }\n}\n",
		"////////////////////////\n// Default the Breakpoints variable\n////////////////////////\n$breakpoints: () !default;\n$BREAKPOINTS: () !default;\n\n////////////////////////\n// Respond-to API Mixin\n////////////////////////\n@mixin respond-to($context, $no-query: false) {\n  @if length($breakpoints) > 0 and length($BREAKPOINTS) == 0 {\n    @warn \"In order to avoid variable namespace collisions, we have updated the way to add breakpoints for respond-to. Please change all instances of `$breakpoints: add-breakpoint()` to `@include add-breakpoint()`. The `add-breakpoint()` function will be deprecated in a future release.\";\n    $BREAKPOINTS: $breakpoints !global;\n    $breakpoints: () !global;\n  }\n\n  @if type-of($BREAKPOINTS) != 'map' {\n    // Just in case someone writes gibberish to the $breakpoints variable.\n    @warn \"Your breakpoints aren't a map! `respond-to` expects a map. Please check the value of $BREAKPOINTS variable.\";\n    @content;\n  }\n  @else if map-has-key($BREAKPOINTS, $context) {\n    @include breakpoint(map-get($BREAKPOINTS, $context), $no-query) {\n      @content;\n    }\n  }\n  @else if not map-has-key($BREAKPOINTS, $context) {\n    @warn \"`#{$context}` isn't a defined breakpoint! Please add it using `$breakpoints: add-breakpoint(`#{$context}`, $value);`\";\n    @content;\n  }\n  @else {\n    @warn \"You haven't created any breakpoints yet! Make some already! `@include add-breakpoint($name, $bkpt)`\";\n    @content;\n  }\n}\n\n//////////////////////////////\n// Add Breakpoint to Breakpoints\n// TODO: Remove function in next release\n//////////////////////////////\n@function add-breakpoint($name, $bkpt, $overwrite: false) {\n  $output: ($name: $bkpt);\n\n  @if length($breakpoints) == 0 {\n    @return $output;\n  }\n  @else {\n    @if map-has-key($breakpoints, $name) and $overwrite != true {\n      @warn \"You already have a breakpoint named `#{$name}`, please choose another breakpoint name, or pass in `$overwrite: true` to overwrite the previous breakpoint.\";\n      @return $breakpoints;\n    }\n    @else if not map-has-key($breakpoints, $name) or $overwrite == true {\n      @return map-merge($breakpoints, $output);\n    }\n  }\n}\n\n@mixin add-breakpoint($name, $bkpt, $overwrite: false) {\n  $output: ($name: $bkpt);\n\n  @if length($BREAKPOINTS) == 0 {\n    $BREAKPOINTS: $output !global;\n  }\n  @else {\n    @if map-has-key($BREAKPOINTS, $name) and $overwrite != true {\n      @warn \"You already have a breakpoint named `#{$name}`, please choose another breakpoint name, or pass in `$overwrite: true` to overwrite the previous breakpoint.\";\n      $BREAKPOINTS: $BREAKPOINTS !global;\n    }\n    @else if not map-has-key($BREAKPOINTS, $name) or $overwrite == true {\n      $BREAKPOINTS: map-merge($BREAKPOINTS, $output) !global;\n    }\n  }\n}\n\n@function get-breakpoint($name: false) {\n  @if $name == false {\n    @return $BREAKPOINTS;\n  }\n  @else {\n    @return map-get($BREAKPOINTS, $name);\n  }\n}\n",
		"@mixin legacy-settings-warning {\n  $legacyVars: (\n    'default-media': 'default media',\n    'default-feature': 'default feature',\n    'force-media-all': 'force all media type',\n    'to-ems': 'to ems',\n    'resolutions': 'transform resolutions',\n    'no-queries': 'no queries',\n    'no-query-fallbacks': 'no query fallbacks',\n    'base-font-size': 'base font size',\n    'legacy-syntax': 'legacy syntax'\n  );\n\n  @each $legacy, $new in $legacyVars {\n    @if global-variable-exists('breakpoint-' + $legacy) {\n      @warn \"In order to avoid variable namspace collisions, we have updated the way to change settings for Breakpoint. Please change all instances of `$breakpoint-#{$legacy}: {{setting}}` to `@include breakpoint-set('#{$new}', {{setting}})`. Variable settings, as well as this warning will be deprecated in a future release.\"\n    }\n  };\n\n  //////////////////////////////\n  // Hand correct each setting\n  //////////////////////////////\n  @if global-variable-exists('breakpoint-default-media') and $breakpoint-default-media != breakpoint-get('default media') {\n    @include breakpoint-set('default media', $breakpoint-default-media);\n  }\n  @if global-variable-exists('breakpoint-default-feature') and $breakpoint-default-feature != breakpoint-get('default feature') {\n    @include breakpoint-set('default feature', $breakpoint-default-feature);\n  }\n  @if global-variable-exists('breakpoint-force-media-all') and $breakpoint-force-media-all != breakpoint-get('force all media type') {\n    @include breakpoint-set('force all media type', $breakpoint-force-media-all);\n  }\n  @if global-variable-exists('breakpoint-to-ems') and $breakpoint-to-ems != breakpoint-get('to ems') {\n    @include breakpoint-set('to ems', $breakpoint-to-ems);\n  }\n  @if global-variable-exists('breakpoint-resolutions') and $breakpoint-resolutions != breakpoint-get('transform resolutions') {\n    @include breakpoint-set('transform resolutions', $breakpoint-resolutions);\n  }\n  @if global-variable-exists('breakpoint-no-queries') and $breakpoint-no-queries != breakpoint-get('no queries') {\n    @include breakpoint-set('no queries', $breakpoint-no-queries);\n  }\n  @if global-variable-exists('breakpoint-no-query-fallbacks') and $breakpoint-no-query-fallbacks != breakpoint-get('no query fallbacks') {\n    @include breakpoint-set('no query fallbacks', $breakpoint-no-query-fallbacks);\n  }\n  @if global-variable-exists('breakpoint-base-font-size') and $breakpoint-base-font-size != breakpoint-get('base font size') {\n    @include breakpoint-set('base font size', $breakpoint-base-font-size);\n  }\n  @if global-variable-exists('breakpoint-legacy-syntax') and $breakpoint-legacy-syntax != breakpoint-get('legacy syntax') {\n    @include breakpoint-set('legacy syntax', $breakpoint-legacy-syntax);\n  }\n}",
		"// Functions module\n//\n// The main module for Chroma.\n//\n// Weight: -1\n//\n// Style guide: functions\n\n// Import the global variables and internal functions needed by all of Chroma.\n@import './variables';\n@import './internals';\n\n// Initialize the $chroma data structure.\n$chroma: _chroma-init();\n\n\n// is-dangerous-color-keyword($name)\n//\n// This function is used by color(), add-colors() and others to check if the\n// given color name is a \"dangerous\" color keyword. Returns false or causes the\n// Sass compilation to die with an error message containing the name of the\n// dangerous color keyword.\n//\n// If a real Sass color is given as a color name to Chroma, it is in danger of\n// being converted to a hexadecimal value before Chroma can read the name. (This\n// happens when Sass' \"compressed\" output style is used.) And some hex values\n// map to more than one keyword (e.g. gray/grey and fuchsia/magenta), so the\n// original name would be irretrievable.\n//\n// Since Chroma will confuse fuchsia and magenta (among others) under Sass'\n// \"compressed\" output style, it would generate confusing results. To prevent\n// this, Chroma halts Sass compilation when it detects an ambiguous color\n// keyword. While the error only occurs under Sass' \"compressed\" output style,\n// Chroma halts under all output styles. Otherwise, Chroma could behave\n// differently on production vs. development environments. If you are really\n// sure Chroma will never be run with Sass' \"compressed\" output style, you can\n// disable this feature by setting `$chroma-die-on-dangerous-keyword: false;`.\n//\n// $name - The name of the color to check.\n//\n// Style guide: functions.is-dangerous-color-keyword\n@function is-dangerous-color-keyword($name) {\n  // First, double-check if this is a keyword in a string.\n  @if _is-keyword-string($name) {\n    @return false;\n  }\n\n  @if type-of($name) == 'color' {\n    $lookup: '';\n    @if _is-old-libsass() {\n      // Forcibly convert a color keyword into a string with a \"salt\".\n      $lookup: \"keyword:#{$name}\";\n    }\n    @else {\n      // Convert the color to a string.\n      $lookup: inspect($name);\n    }\n    // Check if Sass will convert the color into a hex value that we can't\n    // convert back to a keyword.\n    @if map-has-key($_chroma-dangerous-keywords, $lookup) {\n      @if $chroma-die-on-dangerous-keyword {\n        @error \"Sass will convert #{$name} into a hexidecimal value when it uses the \\\"compressed\\\" output style and Chroma will not be able to determine if the original name was #{map-get($_chroma-dangerous-keywords, $lookup)}. To prevent this error, quote the keyword like this: '#{$name}'.\";\n      }\n      @else {\n        @return map-get($_chroma-dangerous-keywords, $lookup);\n      }\n    }\n    // Check if Sass _has_ converted the color into a hex value that we can't\n    // convert back to a keyword.\n    @else if map-has-key($_chroma-dangerous-converted-keywords, $lookup) {\n      @error \"Sass has converted a #{$_chroma-spelling} keyword into the hexidecimal value, #{$name}, and Chroma was not be able to determine if the original name was #{map-get($_chroma-dangerous-converted-keywords, $lookup)}. To prevent this error, use quotes around the keyword.\";\n    }\n  }\n  @return false;\n}\n\n// is-color-keyword($name)\n//\n// Checks if the given name is a color keyword. Returns false or a string\n// containing the name of the color keyword.\n//\n// $name - The name of the color to check.\n//\n// Style guide: functions.is-color-keyword\n@function is-color-keyword($name) {\n  // First, double-check if this is a keyword in a string.\n  @if _is-keyword-string($name) {\n    @return false;\n  }\n\n  // If a real Sass color is given, it is in danger of being converted to a\n  // hexadecimal value before we can read the name. And some hex values map to\n  // more than one keyword (e.g. gray and grey), so the original name would be\n  // irretrievable.\n  //\n  // While is-dangerous-color-keyword() would normally @error before it\n  // returned, if it does return a true value, we should continue inspecting\n  // $name so we can convert it to a string.\n  $is-dangerous: is-dangerous-color-keyword($name);\n\n  @if type-of($name) == 'color' {\n    $lookup: '';\n\n    @if _is-old-libsass() {\n      // Forcibly convert a color keyword into a string with a \"salt\".\n      $lookup: \"keyword:#{$name}\";\n    }\n    @else {\n      // Convert the color to a string.\n      $lookup: inspect($name);\n    }\n\n    @return if(map-has-key($_chroma-css4-color-keywords, $lookup), map-get($_chroma-css4-color-keywords, $lookup), false);\n  }\n\n  @return false;\n}\n\n// chroma-to-string($name)\n//\n// Cast the color name to a string to ensure color keywords do not cause\n// problems as map keys.\n//\n// $name - The name of the color to convert.\n//\n// Style guide: functions.chroma-to-string\n@function chroma-to-string($name) {\n  // If the name is a color keyword, is-color-keyword() converts it to a string.\n  $is-keyword: is-color-keyword($name);\n  @return if($is-keyword, $is-keyword, $name);\n}\n\n// color([$scheme,] $name)\n//\n// Returns a color value given a key word and optional color scheme. If the\n// named color is not in the color scheme, the color scheme's parent scheme will\n// be searched.\n//\n// Usage:\n// ```scss\n// .ex {\n//   background-color: color(body-bg);\n//   border: 1px solid color(grace, border);\n// }\n// ```\n//\n// $scheme - Optional color scheme to choose from; defaults to\n//           `$chroma-active-scheme`.\n// $name   - The name of the requested color.\n//\n// Style guide: functions.color\n@function color($scheme, $name: null) {\n  @if type-of($name) == 'null' {\n    // The shortcut syntax was used since $name is null. Move the color name to\n    // the $name parameter and set a default value to $scheme.\n    $name: $scheme;\n    $scheme: $chroma-active-scheme;\n  }\n\n  // Confirm the scheme exists.\n  @if not chroma-has-scheme($scheme) {\n    @error 'The #{$_chroma-spelling} scheme \"#{$scheme}\" was not found.';\n  }\n  // Cast the color name to a string to ensure color keywords do not cause\n  // problems as map keys.\n  $name: chroma-to-string($name);\n  // Find the actual scheme used by the named color.\n  $actual-scheme: chroma-has-color($name, $scheme);\n  @if not $actual-scheme {\n    @error 'The #{$_chroma-spelling} \"#{$name}\" was not found.';\n  }\n  $color: map-get(map-get($chroma, 'names'), \"#{$actual-scheme}::#{$name}\");\n  @if $actual-scheme == $scheme {\n    @return map-get($color, 'value');\n  }\n  @else {\n    // The value of $actual-scheme::$name is based on colors in $actual-scheme\n    // and its parent schemes. But one or more of the parent colors may be\n    // defined (overridden) in $scheme too, so we need to check the full\n    // reference chain.\n    $chain: ();\n    $ref: map-get($color, 'reference');\n    @if $ref and map-get($color, 'function') {\n      $chain: append($chain, $color);\n    }\n    @while $ref {\n      $actual-scheme: chroma-has-color($ref, $scheme);\n      $color: map-get(map-get($chroma, 'names'), \"#{$actual-scheme}::#{$ref}\");\n      $ref: map-get($color, 'reference');\n      // Save any color that has a function unless it is the final color in the\n      // reference chain.\n      @if $ref and map-get($color, 'function') {\n        $chain: append($chain, $color);\n      }\n    }\n    // Find the value for the last non-reference in the chain.\n    $value: map-get($color, 'value');\n    // If the reference chain contains functions, we need to recalculate all\n    // the values back up the chain.\n    @if length($chain) > 0 {\n      @for $i from length($chain) through 1 {\n        $function: map-get(nth($chain, $i), 'function');\n        $parameters: map-get(nth($chain, $i), 'parameters');\n        $parameters: set-nth($parameters, 1, $value);\n        $value: _safe-call($function, $parameters...);\n      }\n    }\n    @return $value;\n  }\n}\n\n// define-color-scheme($scheme [, $description] [, $parent])\n//\n// Define a new color scheme and, optionally, set its description and parent\n// color scheme.\n//\n// When searching for a color and the color scheme does not define that\n// particular color, the parent color scheme will be checked to see if it\n// defines that color.\n//\n// By default, all color schemes inherit their colors from the default color\n// scheme. Optionally, a color scheme can choose to inherit from a different\n// color scheme by specifying the `$parent` parameter.\n//\n// Usage:\n// ```scss\n// $chroma: define-color-scheme(taiwan, \"Taiwan's colors\");\n// $chroma: define-color-scheme(taipei, \"Taipei's colors\", $parent: taiwan);\n// ```\n//\n// $scheme      - The name of the new color scheme.\n// $description - Optional description of the color scheme.\n// $parent      - The parent color scheme to inherit colors from; defaults to\n//                `default` (i.e. `$CHROMA_DEFAULT_SCHEME`).\n//\n// Style guide: functions.define-color-scheme\n@function define-color-scheme($scheme, $description: '', $parent: $CHROMA_DEFAULT_SCHEME) {\n  // Check if we are defining the default color scheme.\n  @if $scheme == $CHROMA_DEFAULT_SCHEME {\n    $parent: false;\n  }\n\n  // Check parent reference exists.\n  @if $parent and not chroma-has-scheme($parent) {\n    @error 'Cannot set the parent of #{scheme} to \"#{$parent}\" because the #{$_chroma-spelling} scheme \"#{$parent}\" was not found.';\n  }\n\n  $schemes: map-merge(\n    map-get($chroma, 'schemes'),\n    ($scheme: (\n      'description': $description,\n      'parent': $parent,\n    ))\n  );\n\n  $chroma: map-merge(\n    $chroma,\n    ('schemes': $schemes)\n  ) !global;\n\n  @return $chroma;\n}\n\n// define-default-color-scheme([$name,] $description)\n//\n// Sets the description of the default color scheme.\n//\n// Usage:\n// ```scss\n// $chroma: define-default-color-scheme('Default colors');\n// // or:\n// $chroma: define-default-color-scheme('branding', 'Basic branding colors');\n// ```\n//\n// $name - Optional: default color scheme name; defaults to `default`.\n// $description - Description of the default color scheme.\n//\n// Style guide: functions.define-default-color-scheme\n@function define-default-color-scheme($name, $description: null) {\n  @if type-of($description) == 'null' {\n    // The shortcut syntax was used since $description is null. Move the actual\n    // description to the $description parameter.\n    $description: $name;\n    @return define-color-scheme($CHROMA_DEFAULT_SCHEME, $description);\n  }\n\n  // Remove the old default.\n  $schemes: map-remove(map-get($chroma, 'schemes'), $CHROMA_DEFAULT_SCHEME);\n  // Update all child schemes of the default.\n  @each $scheme-name, $map in $schemes {\n    @if map-get($map, 'parent') == $CHROMA_DEFAULT_SCHEME {\n      $schemes: map-merge(\n        $schemes,\n        ($scheme-name: (\n          'description': map-get($map, 'description'),\n          'parent': $name,\n        ))\n      );\n    }\n  }\n  // Set the new default scheme name and, if needed, the new active scheme.\n  @if $chroma-active-scheme == $CHROMA_DEFAULT_SCHEME {\n    $chroma-active-scheme: $name !global;\n  }\n  $CHROMA_DEFAULT_SCHEME: $name !global;\n  // Add the default scheme (and the updated schemes) back into $chroma.\n  $chroma: map-merge(\n    $chroma,\n    ('schemes': map-merge(\n      $schemes,\n      ($name: (\n        'description': $description,\n        'parent': false,\n      ))\n    ))\n  ) !global;\n\n  @return $chroma;\n}\n\n// add-colors([$scheme,] $colors)\n//\n// Add the colors to an existing color scheme.\n//\n// Usage:\n// ```scss\n// $chroma: add-colors('admiral', (\n//  link:        #0000cc,\n//  nav:         link, // Sets this color to the same value as the \"link\" color.\n//  nav-visited: (nav darken 20%), // Takes the \"nav\" color and passes it\n//                                 // through darken([color], 20%)\n//  nav-focus:   (nav lighten 10%),\n// ));\n// ```\n//\n// If you wish to add colors to the active scheme, you can just use:\n// ```scss\n// $chroma: add-colors((\n//  link:        #0000cc,\n//  nav:         link,\n//  nav-visited: (link darken 20%),\n//  nav-focus:   (link lighten 10%),\n// ));\n// ```\n//\n// $scheme - Optional: color scheme to add colors to; defaults to\n//           `$chroma-active-scheme`.\n// $colors - A Sass map containing the new colors.\n//\n// Style guide: functions.add-colors\n@function add-colors($scheme, $colors: null) {\n  @if type-of($scheme) == 'map' or type-of($scheme) == 'list' {\n    // The shortcut syntax was used since only a map of $colors was given as the\n    // first parameter. Move the map to the $colors parameter and set a default\n    // value to $scheme.\n    $colors: $scheme;\n    $scheme: $chroma-active-scheme;\n  }\n  @if not chroma-has-scheme($scheme) {\n    @error 'The #{$_chroma-spelling} scheme \"#{$scheme}\" was not found.';\n  }\n  @each $color-name, $color-value in $colors {\n    // Cast the color name to a string to ensure color keywords do not cause\n    // problems as map keys.\n    $color-name: chroma-to-string($color-name);\n    $color-function: false;\n    $color-parameters: ();\n    // If the \"value\" is a list, its a value plus a function.\n    @if type-of($color-value) == 'list' {\n      $color-function: nth($color-value, 2);\n      @if not function_exists($color-function) {\n        @error 'The function \"#{$color-function}\" was not found when adding the #{$_chroma-spelling} \"#{$color-name}\".';\n      }\n      // Include the color value in the list of function parameters.\n      @for $i from 1 through length($color-value) {\n        @if $i != 2 {\n          $color-parameters: append($color-parameters, nth($color-value, $i));\n        }\n      }\n      $color-value: nth($color-value, 1);\n    }\n    // If the value given is a color, just add it.\n    @if type-of($color-value) == 'color' and not (_is-old-libsass() and _is-keyword-string($color-value)) {\n      @if $color-function {\n        $color-value: _safe-call($color-function, $color-parameters...);\n      }\n      $chroma: _chroma-add-name($scheme, $color-name,\n        $value          : $color-value,\n        $reference      : false,\n        $referenced_by  : (),\n        $function       : $color-function,\n        $parameters     : $color-parameters\n      ) !global;\n    }\n    // If the value given is a reference to another color...\n    @else if type-of($color-value) == 'string' or (_is-old-libsass() and _is-keyword-string($color-value)) {\n      $ref: $color-value;\n      // Find the referenced color.\n      $scheme-of-reference: chroma-has-color($ref, $scheme);\n      @if not $scheme-of-reference {\n        @error 'The #{$_chroma-spelling} \"#{$ref}\" was not found when adding the #{$_chroma-spelling} \"#{$color-name}\".';\n      }\n      $referenced-color: map-get(map-get($chroma, 'names'), \"#{$scheme-of-reference}::#{$ref}\");\n      // Add the new color.\n      $new-value: map-get($referenced-color, 'value');\n      @if $color-function {\n        $color-parameters: set-nth($color-parameters, 1, $new-value);\n        $new-value: _safe-call($color-function, $color-parameters...);\n      }\n      $chroma: _chroma-add-name($scheme, $color-name,\n        $value         : $new-value,\n        $reference     : $ref,\n        $referenced_by : (),\n        $function      : $color-function,\n        $parameters    : $color-parameters\n      ) !global;\n      // Document the new color in all the referenced_by lists.\n      @while $ref {\n        $chroma: _chroma-add-name($scheme-of-reference, $ref,\n          $value         : map-get($referenced-color, 'value'),\n          $reference     : map-get($referenced-color, 'reference'),\n          $referenced_by : append(\n            map-get($referenced-color, 'referenced_by'),\n            $color-name\n          ),\n          $function      : map-get($referenced-color, 'function'),\n          $parameters    : map-get($referenced-color, 'parameters')\n        ) !global;\n        $ref: map-get($referenced-color, 'reference');\n        @if $ref {\n          $scheme-of-reference: chroma-has-color($ref, $scheme);\n          $referenced-color: map-get(map-get($chroma, 'names'), \"#{$scheme-of-reference}::#{$ref}\");\n        }\n      }\n    }\n    @else {\n      @error 'Unexpected value, \"#{$color-value}\", given for #{$_chroma-spelling} \"#{$color-name}\".';\n    }\n  }\n\n  @return $chroma;\n}\n\n// define-skins($skins)\n//\n// Defines one or more color schemes as being a skin. For each of the specified\n// color schemes, `define-skins()` will tell Chroma to use the scheme with the\n// corresponding CSS selector when the `skin()` mixin is used.\n//\n// Usage:\n// ```scss\n// $chroma: define-skins((\n//   'scheme1': '.is-scheme1-skin',\n//   'scheme2': '.is-scheme2-skin',\n//   'scheme3': 'html > body.this-works-but-is.way.too.specific.IMHO',\n// ));\n// ```\n//\n// $skins - A map of color schemes and their CSS parent selectors. Each key in\n// the map must be the name of an existing color scheme. The value of each key\n// is the CSS parent selector that triggers the use of the defined scheme\n// instead of the default color scheme. We recommend using a simple CSS selector\n// like `.is-CUSTOMNAME-skin`.\n//\n// Style guide: skin.define-skins\n@function define-skins($skins) {\n  @each $scheme, $selector in $skins {\n    @if not chroma-has-scheme($scheme) {\n      @error 'The #{$_chroma-spelling} scheme \"#{$scheme}\" was not found.';\n    }\n    @if type-of($selector) != 'string' {\n      @error 'The selector for the #{$scheme} skin was a #{type-of($selector)}, but should be a string.';\n    }\n  }\n\n  $chroma: map-merge(\n    $chroma,\n    ('skins': map-merge(\n      map-get($chroma, 'skins'),\n      $skins\n    ))\n  ) !global;\n\n  @return $chroma;\n}\n\n// define-skin($scheme, $selector)\n//\n// Deprecated: Will be removed in Chroma 2.0.0. Use `define-skins()` instead.\n//\n// Weight: 100\n//\n// Style guide: skin.define-skin\n@function define-skin($scheme, $selector) {\n  @warn \"The define-skin() function is deprecated. Use define-skins() instead.\";\n  @return define-skins(($scheme: $selector));\n}\n",
		"// Variables module\n//\n// This module contains all the public and private variables needed for Chroma\n// to function. Only public variables are documented.\n//\n// Auto-imported by other modules.\n//\n// Weight: -2\n//\n// Style guide: variables\n\n//\n// Public variables.\n//\n\n// $chroma\n//\n// The colors and meta-data managed by Chroma.\n//\n// Chroma stores all of its colors, color schemes, skins etc. in the global\n// sass variable, `$chroma`. All of Chroma's configuration functions are\n// designed to save their changes to the system by changing the value of the\n// `$chroma` variable. For example: `$chroma: add-colors((kermit, #70af00));`\n//\n// Note: since the `$chroma` variable is a complex map of data structures, it\n// is highly recommended to only access `$chroma` through the functions and\n// mixins provided and not attempt to read data from `$chroma` with Sass'\n// `map-get()` and `map-set()` functions. (If you find you need more helper\n// functions, submit a feature request! We're happy to help.)\n//\n// Style guide: variables.chroma\n$chroma: () !default;\n\n// $CHROMA_DEFAULT_SCHEME\n//\n// The name of the default color scheme; defaults to `default`. This variable\n// is READ ONLY; changing its value will break Chroma.\n//\n// If you want to change this variable's value, you must use the\n// `define-default-color-scheme()` function instead.\n//\n// Style guide: variables.CHROMA_DEFAULT_SCHEME\n$CHROMA_DEFAULT_SCHEME: 'default';\n\n// $chroma-active-scheme\n//\n// The currently active color scheme. This is the default value used by the\n// $scheme parameter of most Chroma functions.\n//\n// By default, this variable is set to the 'default' color scheme.\n//\n// Style guide: variables.chroma-active-scheme\n$chroma-active-scheme: $CHROMA_DEFAULT_SCHEME !default;\n\n// $chroma-die-on-dangerous-keyword\n//\n// Controls whether Chroma will halt Sass compilation if it encounters a\n// \"dangerous color keyword\".\n//\n// See the docs of is-dangerous-color-keyword() for more information.\n//\n// Style guide: variables.chroma-die-on-dangerous-keyword\n$chroma-die-on-dangerous-keyword: true !default;\n\n//\n// Private variables.\n//\n\n// Let the Aussies, etc. have their preferred spelling.\n//\n// Rather than setting this variable directly, users should import the colour\n// module with: `@import 'chroma/colour';`\n$_chroma-spelling: 'color' !default;\n\n// The following keywords will cause confusion if used as color names. See the\n// docs of is-dangerous-color-keyword() for more information.\n$_chroma-dangerous-keywords: (\n  'aqua': 'aqua or cyan',\n  'cyan': 'aqua or cyan',\n  'fuchsia': 'fuchsia or magenta',\n  'magenta': 'fuchsia or magenta',\n  'darkgray': 'darkgray or darkgrey',\n  'darkgrey': 'darkgray or darkgrey',\n  'darkslategray': 'darkslategray or darkslategrey',\n  'darkslategrey': 'darkslategray or darkslategrey',\n  'dimgray': 'dimgray or dimgrey',\n  'dimgrey': 'dimgray or dimgrey',\n  'gray': 'gray or grey',\n  'grey': 'gray or grey',\n  'lightgray': 'lightgray or lightgrey',\n  'lightgrey': 'lightgray or lightgrey',\n  'lightslategray': 'lightslategray or lightslategrey',\n  'lightslategrey': 'lightslategray or lightslategrey',\n  'slategray': 'slategray or slategrey',\n  'slategrey': 'slategray or slategrey',\n);\n\n// The following color values are the converted values of dangerous color\n// keywords. If Chroma sees these values as color names, it means Sass converted\n// the original color name before Chroma could see it. See the docs of\n// is-dangerous-color-keyword() for more information.\n$_chroma-dangerous-converted-keywords: (\n  '#00ffff': 'aqua or cyan',\n  '#0ff': 'aqua or cyan',\n  '#ff00ff': 'fuchsia or magenta',\n  '#f0f': 'fuchsia or magenta',\n  '#a9a9a9': 'darkgray or darkgrey',\n  '#2f4f4f': 'darkslategray or darkslategrey',\n  '#696969': 'dimgray or dimgrey',\n  '#808080': 'gray or grey',\n  '#d3d3d3': 'lightgray or lightgrey',\n  '#778899': 'lightslategray or lightslategrey',\n  '#789': 'lightslategray or lightslategrey',\n  '#708090': 'slategray or slategrey',\n);\n\n// We need to identify color names that are also color keywords so we can safely\n// convert them to strings. Hex values are also included in the list since Sass\n// may convert keywords to hex before Chroma can see them; this allows us to\n// safely convert them back.\n//\n// This is the full list of CSS4 color keywords including the dangerous ones.\n// From http://dev.w3.org/csswg/css-color-4/#named-colors\n$_chroma-css4-color-keywords: (\n  'aliceblue': 'aliceblue',\n  '#f0f8ff': 'aliceblue',\n  'antiquewhite': 'antiquewhite',\n  '#faebd7': 'antiquewhite',\n  'aqua': 'aqua',\n  'aquamarine': 'aquamarine',\n  '#7fffd4': 'aquamarine',\n  'azure': 'azure',\n  '#f0ffff': 'azure',\n  'beige': 'beige',\n  '#f5f5dc': 'beige',\n  'bisque': 'bisque',\n  '#ffe4c4': 'bisque',\n  'black': 'black',\n  '#000000': 'black',\n  '#000': 'black',\n  'blanchedalmond': 'blanchedalmond',\n  '#ffebcd': 'blanchedalmond',\n  'blue': 'blue',\n  '#0000ff': 'blue',\n  '#00f': 'blue',\n  'blueviolet': 'blueviolet',\n  '#8a2be2': 'blueviolet',\n  'brown': 'brown',\n  '#a52a2a': 'brown',\n  'burlywood': 'burlywood',\n  '#deb887': 'burlywood',\n  'cadetblue': 'cadetblue',\n  '#5f9ea0': 'cadetblue',\n  'chartreuse': 'chartreuse',\n  '#7fff00': 'chartreuse',\n  'chocolate': 'chocolate',\n  '#d2691e': 'chocolate',\n  'coral': 'coral',\n  '#ff7f50': 'coral',\n  'cornflowerblue': 'cornflowerblue',\n  '#6495ed': 'cornflowerblue',\n  'cornsilk': 'cornsilk',\n  '#fff8dc': 'cornsilk',\n  'crimson': 'crimson',\n  '#dc143c': 'crimson',\n  'cyan': 'cyan',\n  '#00ffff': 'cyan',\n  '#0ff': 'cyan',\n  'darkblue': 'darkblue',\n  '#00008b': 'darkblue',\n  'darkcyan': 'darkcyan',\n  '#008b8b': 'darkcyan',\n  'darkgoldenrod': 'darkgoldenrod',\n  '#b8860b': 'darkgoldenrod',\n  'darkgray': 'darkgray',\n  '#a9a9a9': 'darkgray',\n  'darkgreen': 'darkgreen',\n  '#006400': 'darkgreen',\n  'darkgrey': 'darkgrey',\n  'darkkhaki': 'darkkhaki',\n  '#bdb76b': 'darkkhaki',\n  'darkmagenta': 'darkmagenta',\n  '#8b008b': 'darkmagenta',\n  'darkolivegreen': 'darkolivegreen',\n  '#556b2f': 'darkolivegreen',\n  'darkorange': 'darkorange',\n  '#ff8c00': 'darkorange',\n  'darkorchid': 'darkorchid',\n  '#9932cc': 'darkorchid',\n  'darkred': 'darkred',\n  '#8b0000': 'darkred',\n  'darksalmon': 'darksalmon',\n  '#e9967a': 'darksalmon',\n  'darkseagreen': 'darkseagreen',\n  '#8fbc8f': 'darkseagreen',\n  'darkslateblue': 'darkslateblue',\n  '#483d8b': 'darkslateblue',\n  'darkslategray': 'darkslategray',\n  '#2f4f4f': 'darkslategray',\n  'darkslategrey': 'darkslategrey',\n  'darkturquoise': 'darkturquoise',\n  '#00ced1': 'darkturquoise',\n  'darkviolet': 'darkviolet',\n  '#9400d3': 'darkviolet',\n  'deeppink': 'deeppink',\n  '#ff1493': 'deeppink',\n  'deepskyblue': 'deepskyblue',\n  '#00bfff': 'deepskyblue',\n  'dimgray': 'dimgray',\n  '#696969': 'dimgray',\n  'dimgrey': 'dimgrey',\n  'dodgerblue': 'dodgerblue',\n  '#1e90ff': 'dodgerblue',\n  'firebrick': 'firebrick',\n  '#b22222': 'firebrick',\n  'floralwhite': 'floralwhite',\n  '#fffaf0': 'floralwhite',\n  'forestgreen': 'forestgreen',\n  '#228b22': 'forestgreen',\n  'fuchsia': 'fuchsia',\n  'gainsboro': 'gainsboro',\n  '#dcdcdc': 'gainsboro',\n  'ghostwhite': 'ghostwhite',\n  '#f8f8ff': 'ghostwhite',\n  'gold': 'gold',\n  '#ffd700': 'gold',\n  'goldenrod': 'goldenrod',\n  '#daa520': 'goldenrod',\n  'gray': 'gray',\n  '#808080': 'gray',\n  'green': 'green',\n  '#008000': 'green',\n  'greenyellow': 'greenyellow',\n  '#adff2f': 'greenyellow',\n  'grey': 'grey',\n  'honeydew': 'honeydew',\n  '#f0fff0': 'honeydew',\n  'hotpink': 'hotpink',\n  '#ff69b4': 'hotpink',\n  'indianred': 'indianred',\n  '#cd5c5c': 'indianred',\n  'indigo': 'indigo',\n  '#4b0082': 'indigo',\n  'ivory': 'ivory',\n  '#fffff0': 'ivory',\n  'khaki': 'khaki',\n  '#f0e68c': 'khaki',\n  'lavender': 'lavender',\n  '#e6e6fa': 'lavender',\n  'lavenderblush': 'lavenderblush',\n  '#fff0f5': 'lavenderblush',\n  'lawngreen': 'lawngreen',\n  '#7cfc00': 'lawngreen',\n  'lemonchiffon': 'lemonchiffon',\n  '#fffacd': 'lemonchiffon',\n  'lightblue': 'lightblue',\n  '#add8e6': 'lightblue',\n  'lightcoral': 'lightcoral',\n  '#f08080': 'lightcoral',\n  'lightcyan': 'lightcyan',\n  '#e0ffff': 'lightcyan',\n  'lightgoldenrodyellow': 'lightgoldenrodyellow',\n  '#fafad2': 'lightgoldenrodyellow',\n  'lightgray': 'lightgray',\n  '#d3d3d3': 'lightgray',\n  'lightgreen': 'lightgreen',\n  '#90ee90': 'lightgreen',\n  'lightgrey': 'lightgrey',\n  'lightpink': 'lightpink',\n  '#ffb6c1': 'lightpink',\n  'lightsalmon': 'lightsalmon',\n  '#ffa07a': 'lightsalmon',\n  'lightseagreen': 'lightseagreen',\n  '#20b2aa': 'lightseagreen',\n  'lightskyblue': 'lightskyblue',\n  '#87cefa': 'lightskyblue',\n  'lightslategray': 'lightslategray',\n  '#778899': 'lightslategray',\n  '#789': 'lightslategray',\n  'lightslategrey': 'lightslategrey',\n  'lightsteelblue': 'lightsteelblue',\n  '#b0c4de': 'lightsteelblue',\n  'lightyellow': 'lightyellow',\n  '#ffffe0': 'lightyellow',\n  'lime': 'lime',\n  '#00ff00': 'lime',\n  '#0f0': 'lime',\n  'limegreen': 'limegreen',\n  '#32cd32': 'limegreen',\n  'linen': 'linen',\n  '#faf0e6': 'linen',\n  'magenta': 'magenta',\n  '#ff00ff': 'magenta',\n  '#f0f': 'magenta',\n  'maroon': 'maroon',\n  '#800000': 'maroon',\n  'mediumaquamarine': 'mediumaquamarine',\n  '#66cdaa': 'mediumaquamarine',\n  'mediumblue': 'mediumblue',\n  '#0000cd': 'mediumblue',\n  'mediumorchid': 'mediumorchid',\n  '#ba55d3': 'mediumorchid',\n  'mediumpurple': 'mediumpurple',\n  '#9370db': 'mediumpurple',\n  'mediumseagreen': 'mediumseagreen',\n  '#3cb371': 'mediumseagreen',\n  'mediumslateblue': 'mediumslateblue',\n  '#7b68ee': 'mediumslateblue',\n  'mediumspringgreen': 'mediumspringgreen',\n  '#00fa9a': 'mediumspringgreen',\n  'mediumturquoise': 'mediumturquoise',\n  '#48d1cc': 'mediumturquoise',\n  'mediumvioletred': 'mediumvioletred',\n  '#c71585': 'mediumvioletred',\n  'midnightblue': 'midnightblue',\n  '#191970': 'midnightblue',\n  'mintcream': 'mintcream',\n  '#f5fffa': 'mintcream',\n  'mistyrose': 'mistyrose',\n  '#ffe4e1': 'mistyrose',\n  'moccasin': 'moccasin',\n  '#ffe4b5': 'moccasin',\n  'navajowhite': 'navajowhite',\n  '#ffdead': 'navajowhite',\n  'navy': 'navy',\n  '#000080': 'navy',\n  'oldlace': 'oldlace',\n  '#fdf5e6': 'oldlace',\n  'olive': 'olive',\n  '#808000': 'olive',\n  'olivedrab': 'olivedrab',\n  '#6b8e23': 'olivedrab',\n  'orange': 'orange',\n  '#ffa500': 'orange',\n  'orangered': 'orangered',\n  '#ff4500': 'orangered',\n  'orchid': 'orchid',\n  '#da70d6': 'orchid',\n  'palegoldenrod': 'palegoldenrod',\n  '#eee8aa': 'palegoldenrod',\n  'palegreen': 'palegreen',\n  '#98fb98': 'palegreen',\n  'paleturquoise': 'paleturquoise',\n  '#afeeee': 'paleturquoise',\n  'palevioletred': 'palevioletred',\n  '#db7093': 'palevioletred',\n  'papayawhip': 'papayawhip',\n  '#ffefd5': 'papayawhip',\n  'peachpuff': 'peachpuff',\n  '#ffdab9': 'peachpuff',\n  'peru': 'peru',\n  '#cd853f': 'peru',\n  'pink': 'pink',\n  '#ffc0cb': 'pink',\n  'plum': 'plum',\n  '#dda0dd': 'plum',\n  'powderblue': 'powderblue',\n  '#b0e0e6': 'powderblue',\n  'purple': 'purple',\n  '#800080': 'purple',\n  'rebeccapurple': 'rebeccapurple',\n  '#663399': 'rebeccapurple',\n  'red': 'red',\n  '#ff0000': 'red',\n  '#f00': 'red',\n  'rosybrown': 'rosybrown',\n  '#bc8f8f': 'rosybrown',\n  'royalblue': 'royalblue',\n  '#4169e1': 'royalblue',\n  'saddlebrown': 'saddlebrown',\n  '#8b4513': 'saddlebrown',\n  'salmon': 'salmon',\n  '#fa8072': 'salmon',\n  'sandybrown': 'sandybrown',\n  '#f4a460': 'sandybrown',\n  'seagreen': 'seagreen',\n  '#2e8b57': 'seagreen',\n  'seashell': 'seashell',\n  '#fff5ee': 'seashell',\n  'sienna': 'sienna',\n  '#a0522d': 'sienna',\n  'silver': 'silver',\n  '#c0c0c0': 'silver',\n  'skyblue': 'skyblue',\n  '#87ceeb': 'skyblue',\n  'slateblue': 'slateblue',\n  '#6a5acd': 'slateblue',\n  'slategray': 'slategray',\n  '#708090': 'slategray',\n  'slategrey': 'slategrey',\n  'snow': 'snow',\n  '#fffafa': 'snow',\n  'springgreen': 'springgreen',\n  '#00ff7f': 'springgreen',\n  'steelblue': 'steelblue',\n  '#4682b4': 'steelblue',\n  'tan': 'tan',\n  '#d2b48c': 'tan',\n  'teal': 'teal',\n  '#008080': 'teal',\n  'thistle': 'thistle',\n  '#d8bfd8': 'thistle',\n  'tomato': 'tomato',\n  '#ff6347': 'tomato',\n  'turquoise': 'turquoise',\n  '#40e0d0': 'turquoise',\n  'violet': 'violet',\n  '#ee82ee': 'violet',\n  'wheat': 'wheat',\n  '#f5deb3': 'wheat',\n  'white': 'white',\n  '#ffffff': 'white',\n  '#fff': 'white',\n  'whitesmoke': 'whitesmoke',\n  '#f5f5f5': 'whitesmoke',\n  'yellow': 'yellow',\n  '#ffff00': 'yellow',\n  '#ff0': 'yellow',\n  'yellowgreen': 'yellowgreen',\n  '#9acd32': 'yellowgreen',\n);\n\n// libsass before 3.3.0 can't turn color keywords into strings of the same name,\n// so we have to compare map keys using keywords plus a \"salt\" string.\n//\n// @TODO: Remove when LibSass 3.2.5 support is dropped.\n\n$_chroma-css4-color-keywords-in-strings: ();\n@if type-of('white') == 'color' {\n  // Convert the dangerous color keyword list.\n  $_new-list: ();\n  @each $name, $string in $_chroma-dangerous-keywords {\n    $_new-list: map-merge($_new-list, (\"keyword:#{$name}\": $string));\n  }\n  $_chroma-dangerous-keywords: $_new-list !global;\n\n  // Convert the dangerous converted color keyword list.\n  $_new-list: ();\n  @each $name, $string in $_chroma-dangerous-converted-keywords {\n    $_new-list: map-merge($_new-list, (\"keyword:#{$name}\": $string));\n  }\n  $_chroma-dangerous-converted-keywords: $_new-list !global;\n\n  // Convert the css4 color keyword list, but keep a copy around to check for\n  // color keywords in strings.\n  $_chroma-css4-color-keywords-in-strings: $_chroma-css4-color-keywords !global;\n  $_new-list: ();\n  @each $name, $string in $_chroma-css4-color-keywords {\n    $_new-list: map-merge($_new-list, (\"keyword:#{$name}\": $string));\n  }\n  $_chroma-css4-color-keywords: $_new-list !global;\n}\n",
		"// Internals\n//\n// Helper functions that query the internal data structure in $chroma. These are\n// not part of the public API and are subject to change at any time.\n//\n// Weight: 10\n//\n// Style guide: internals\n\n// Import the global variables needed by all of Chroma.\n@import './variables';\n\n// chroma-has-scheme($scheme)\n//\n// Checks if the named color scheme exists.\n//\n// Style guide: internals.chroma-has-scheme\n@function chroma-has-scheme($scheme) {\n  @return map-has-key(map-get($chroma, 'schemes'), $scheme);\n}\n\n// chroma-schemes()\n//\n// Returns a list of all color schemes in $chroma.\n//\n// Style guide: internals.chroma-schemes\n@function chroma-schemes() {\n  @return map-keys(map-get($chroma, 'schemes'));\n}\n\n// chroma-has-color($name [, $scheme])\n//\n// Checks if the named color exists in the given scheme or its parent schemes.\n// Returns false or a string of the scheme name that contains the color.\n//\n// Style guide: internals.chroma-has-color\n@function chroma-has-color($name, $scheme: $chroma-active-scheme) {\n  $current-scheme: $scheme;\n  @while $current-scheme {\n    @if map-has-key(map-get($chroma, 'names'), \"#{$current-scheme}::#{$name}\") {\n      @return $current-scheme;\n    }\n    // Look in the parent scheme.\n    $current-scheme: map-get(map-get(map-get($chroma, 'schemes'), $current-scheme), 'parent');\n  }\n  @return false;\n}\n\n// _chroma-add-name()\n//\n// Private function that adds a color to the data structure of the $chroma\n// variable.\n//\n// Style guide: internals._chroma-add-name\n@function _chroma-add-name($scheme, $name, $value: false, $reference: false, $referenced_by: (), $function: false, $parameters: ()) {\n  $names: map-merge(\n    map-get($chroma, 'names'),\n    (\"#{$scheme}::#{$name}\": (\n      value         : $value,\n      reference     : $reference,\n      referenced_by : $referenced_by,\n      function      : $function,\n      parameters    : $parameters,\n    ))\n  );\n\n  @return map-merge(\n    $chroma,\n    ('names': $names)\n  );\n}\n\n// _chroma-init()\n//\n// Private function that sets up the initial data structure of the $chroma\n// variable. Can be called repeatedly without damaging existing data.\n//\n// Style guide: internals._chroma-init\n@function _chroma-init() {\n  @if length($chroma) == 0 {\n    @return (\n      'schemes': (\n        $CHROMA_DEFAULT_SCHEME : (\n          'description': '',\n          'parent': false,\n        ),\n      ),\n      'skins': (),\n      'names': (),\n    );\n  }\n  @else {\n    @return $chroma;\n  }\n}\n\n// is-old-libsass()\n//\n// libsass before 3.3.0 is funky, making it very hard for Chroma to do its job.\n//\n// - `inspect([color])` returns the original value instead of returning the\n//   string equivalent, so you can't cast a color to a string.\n// - `type-of('[color keyword]')` thinks that these strings are colors.\n// - `map-has-key()` works properly, thankfully. So:\n//   - `map-has-key((white: ''), white)` correctly returns `true`\n//   - `map-has-key(('white': ''), 'white')` correctly returns `true`\n//   - `map-has-key((white: ''), 'white')` correctly returns `false`\n//   - `map-has-key(('white': ''), white)` correctly returns `false`\n//   This means we can cobble together a replacement for `type-of()`. And a\n//   partial replacement for `inspect()` that works for everything except\n//   dangerous color keywords.\n//\n// @TODO: Remove when LibSass 3.2.5 support is dropped.\n//\n// Style guide: internals._is-old-libsass\n@function _is-old-libsass() {\n  @return if(type-of('white') == 'color', true, false);\n}\n\n// _is-keyword-string($name)\n//\n// Normally, `type-of()` can be used to tell if a given value is a string. But\n// LibSass versions before 3.3.0 think that color keywords in strings are still\n// colors and not strings. This function works, regardless of LibSass bugs.\n//\n// @TODO: Remove when LibSass 3.2.5 support is dropped.\n//\n// Style guide: internals._is-keyword-string\n@function _is-keyword-string($name) {\n  @return if(map-has-key($_chroma-css4-color-keywords-in-strings, $name), true, false);\n}\n\n// _safe-call()\n//\n// LibSass incorrectly throws an error when using the variable argument\n// indicator, ..., with an overloaded function; e.g. rgba(). To work-around this\n// bug, we call rgba() with direct parameters.\n//\n// @TODO: Remove when the fix for https://github.com/sass/libsass/issues/2205 is released.\n//\n// Style guide: internals._safe-call\n@function _safe-call($function, $parameters...) {\n  @if $function == rgba {\n    @return rgba(nth($parameters, 1), nth($parameters, 2));\n  }\n  @return call($function, $parameters...);\n}\n",
		"// sass-lint:disable indentation, no-color-keywords\n\n// Colors\n//\n// Use the `color()` function to add colors to CSS properties. To learn more,\n// [read the Chroma documentation](http://johnalbin.github.io/chroma/).\n//\n// Markup: chroma.twig\n//\n// Weight: -8\n//\n// Style guide: init.colors\n\n// Define the default color scheme's color names.\n$chroma: define-default-color-scheme('branding', 'The site\\'s main colors. Can be used to define colors in other color schemes.');\n\n$chroma: add-colors((\n  black:                  #000,\n  charcoal:               #333,\n  ash-grey:               #666,\n  'grey':                 #999,\n  grey-dark:              #555,\n  grey-light:             #f6f6f6,\n  grey-lightest:          #f0f0f0,\n  grey-medium:            #cdcdcd,\n  white:                  #fff,\n  offwhite:               #ff4dff,\n  dark-red:               #b63a1b, // 4.53:1 with light-pink\n  hc-red:                 #d1431f, // 4.63:1 with white\n  light-pink:             #ffdae0, // 4.53:1 with dark-red\n\n  brand-primary:          #ba5840, //#0f3d0f,\n\n  brand-secondary:        #797660,\n\n  brand-tertiary:         #002e62,\n));\n\n// Define color names for functional uses.\n$chroma: define-color-scheme('functional', 'Colors used by functional parts of the design.');\n$chroma: add-colors('functional', (\n  // Colors used in the main content area.\n  text:                   #111,\n  headings:               'text',\n\n  border:                 'grey-light',\n\n  button:                 'text',\n  button-disabled:        'charcoal',\n  button-action:          #3fa940,\n\n  info-notice:            #004695,\n\n  mark-bg:                #ff0,\n  error:                  'dark-red',\n  error-bg:               'light-pink',\n\n  menu-background:        #fff,\n  menu-item-hover:        #333,\n  menu-separator:         #fff,\n  menu-sub-item-background: 'brand-primary',\n  menu-sub-item-hover:    'brand-primary',\n\n  table-background:       #fff,\n  table-border:           #bbb,\n  table-header-cell-background: #2e3d4a,\n  table-header-cell-border: #c8c7c7,\n  table-header-cell-text: #fff,\n  table-cell-border:      #dbdbdb,\n  table-cell-text:        'text',\n\n  footer-background:      #e7e7e7,\n  footer-border:          'brand-primary',\n  footer-text:            'text',\n  footer-headings:        'text',\n));\n\n$chroma-active-scheme: 'functional';\n\n$black: color('black');\n$charcoal: color(charcoal);\n$ash-grey: color(ash-grey);\n$grey: color(charcoal);\n$grey-dark: color(grey-dark);\n$grey-light: color(grey-light);\n$grey-lightest: color(grey-lightest);\n$grey-medium: color(grey-medium);\n$white: color('white');\n$offwhite: color(offwhite);\n$hc-red: color(hc-red);\n$info-notice: color(info-notice);\n\n$brand-primary: color(brand-primary);\n\n$brand-secondary: color(brand-secondary);\n\n$brand-tertiary: color(brand-tertiary);\n\n$text: color('text');\n$headings: color(headings);\n\n$link: #0e6bb3 !default;\n$link-underline: color('charcoal') !default;\n$link-active: #0e6bb3 !default;\n$link-hover: #0e6bb3 !default;\n$link-hover-background: rgba(75%, 75%, 75%, .25) !default;\n$link-visited: #0e6bb3 !default;\n$link-visited-underline: #707070 !default;\n\n$border: color('border');\n\n$button: color('button');\n$button-disabled: color(button-disabled);\n$button-action: color(button-action);\n\n$mark-bg: color(mark-bg);\n$error: color(error);\n$error-bg: color(error-bg);\n\n$menu-background: color(menu-background);\n$menu-item-hover: color(menu-item-hover);\n$menu-separator: color(menu-separator);\n$menu-sub-item-background: color(menu-sub-item-background);\n$menu-sub-item-hover: color(menu-sub-item-hover);\n\n$table-background: color(table-background);\n$table-border: color(table-border);\n$table-header-cell-background: color(table-header-cell-background);\n$table-header-cell-border: color(table-header-cell-border);\n$table-header-cell-text: color(table-header-cell-text);\n$table-cell-border: color(table-cell-border);\n$table-cell-text: color(table-cell-text);\n\n$footer-background: color(footer-background);\n$footer-border: color(footer-border);\n$footer-text: color(footer-text);\n$footer-headings: color(footer-headings);\n\n$search-submit: #0e6bb3;\n",
		"// Variables\n//\n// Set variables for this site. These can be overridden in the scss code later.\n//\n// Weight: -9\n//\n// Style guide: init.variables\n\n/* Vertical rhythm presets =========================================== */\n// The font size set on the root html element.\n$base-font-size: 10px;\n\n// The base line height determines the basic unit of vertical rhythm.\n$base-line-height: 6px;\n\n// The length unit in which to output vertical rhythm values.\n// Supported values: px, em, rem.\n$rhythm-unit: 'rem';\n\n// Whether to output fallback values in px when using rem as the rhythm-unit.\n$rem-with-px-fallback: false;\n\n// Round the line height to the nearest half line height instead of the nearest integral line height.\n$round-to-nearest-half-line: true;\n\n\n/* Breakpoints ======================================================== */\n$mob: 440px;\n$phab: 641px;\n$tab: 766px;\n$lap: 961px;\n$desk: 1153px;\n\n$grid-breakpoints: (\n  xs: 0,\n  sm: $mob,\n  md: $phab,\n  lg: $tab,\n  xl: $lap,\n  xxl: $desk,\n) !default;\n\n// The amount lists, blockquotes and comments are indented.\n$indent-amount: 1.8rem;\n\n// Set the grid sizes with a default value that can be overwritten on a per theme basis.\n$max-grid-width: 1024px !default;\n\n$main-menu-border: false;\n$two-col-layout-sidebar-second: (65%, 30%);\n",
		"// Font faces, stacks and sizes.\n//\n// Font styling and line heights are controlled by the several variables that\n// used by mixins like adjust-font-size-to().\n// These variable and mixins are documented in [Compass](http://compass-style.org/reference/compass/typography/vertical_rhythm/).\n// We also use a custom mixin responsive-typo-map() to make responsive typography much more manageable using sass maps.\n// We import Google fonts in the head of the document and set the base family to be\n// 'Open Sans', sans-serif\n//\n// Style guide: init.variables.typography\n// The default font family.\n$base-font-family: 'Open Sans', sans-serif;\n$font-monospace:   'Courier New', 'DejaVu Sans Mono', monospace, sans-serif;;\n\n// The font sizes for h1-h6.\n$h1-font-size: 2.1 * $base-font-size;\n$h2-font-size: 2.1 * $base-font-size;\n$h3-font-size: 1.8 * $base-font-size;\n$h4-font-size: 1.8 * $base-font-size;\n$h5-font-size: 1.8 * $base-font-size;\n$h6-font-size: 1.8 * $base-font-size;\n$p-font-size: 1.8 * $base-font-size;\n\n$normal-text: (\n  null: (16px, 1.5, 1em 0 1.5em),\n  lg: 18px,\n);\n\n$h1-text: (\n  null: (32px, 3.9rem, 2rem 0 2.7rem)\n);\n\n$h2-text: (\n  null: (28px, 3.6rem, 3.6rem 0 1.8rem)\n);\n\n$h3-text: (\n  null: (24px, 3rem, 3.6rem 0 1.8rem)\n);\n\n$h4-text: (\n  null: (21px, 2.7rem, 3.6rem 0 1.8rem)\n);\n\n$h5-text: (\n  null: (18px, 2.7rem, 3.6rem 0 1.8rem)\n);\n\n$h6-text: (\n  null: (18px, 2.7rem, 3.6rem 0 1.8rem)\n);\n",
		"// Import the required partials for Chroma.\n\n@import './chroma/functions';\n@import './chroma/skin';\n",
		"// Skin module\n//\n// A \"Skin\" module for Chroma.\n//\n// Sometimes design and engineering requirements mean that we need to:\n// - output the colors for default color scheme and one or more additional color\n//   schemes into the same CSS file\n// - and to control which color scheme is used via a \"global\" CSS class name set\n//   on the web pages's `html` or `body` element.\n//\n// For example, the `.my-complexion` component may output a blue text color on\n// most pages, but on pages with a `<html class=\"skin-wicked-witch\">`, the\n// `.my-complexion` component will output a green text color.\n//\n// The Skin module will help with this requirement.\n//\n// After defining your color schemes and their colors, you can define one or\n// more of those schemes as skins while providing the proper CSS parent selector\n// to use for that skin.\n//\n// Weight: -1\n//\n// Style guide: skin\n\n@import \"./functions\";\n\n// skin([$skins])\n//\n// Output the default color and all the colors needed for defined skins.\n//\n// Usage:\n// ```scss\n// h1 {\n//   @include skin() {\n//     color: color(heading);\n//   }\n// }\n// ```\n//\n// $skins - An optional list of color scheme names and selectors to use instead\n//          of the skins defined with `define-skins()`. The format of this list\n//          should match that of the `$skins` parameter in `define-skins()`.\n//\n// Style guide: skin.skin\n@mixin skin($skins: null) {\n  @if type-of($skins) == 'null' {\n    $skins: map-get($chroma, 'skins');\n  }\n\n  // Save the current active scheme.\n  $original-active-scheme: $chroma-active-scheme;\n\n  // Output the default color property.\n  @content;\n\n  @if length($skins) == 0 {\n    @warn \"skin() mixin used, but no skins have been defined in Chroma.\";\n  }\n\n  // Output the color property for each scheme.\n  @each $scheme, $selector in $skins {\n    $chroma-active-scheme: $scheme !global;\n\n    #{$selector} & {\n      @content\n    }\n  }\n\n  // Restore the original active scheme.\n  $chroma-active-scheme: $original-active-scheme !global;\n}\n",
		"// KSS module\n//\n// A basic \"KSS\" module for Chroma.\n//\n// Use `chroma-kss-markup()` to export a chunk of HTML wrapped in a `/* */` CSS\n// comment. Then use `chroma-kss-styles()` to style it.\n//\n// @TODO: These functions and mixins are a bit janky because it exports to HTML\n// directly rather than to JSON or some other exportable data set.\n//\n// Style guide: kss\n\n@import \"./functions\";\n\n// chroma-kss-markup()\n//\n// Returns the HTML needed to display all colors in color() in a KSS style\n// guide. The parameters are used to specify the classes for various elements.\n//\n// Since regular text can only be output with Sass in certain contexts, you must\n// wrap this function call in a CSS comment.\n//\n// Usage:\n// ```scss\n// // Include chroma's optional kss module.\n// @import 'chroma/kss';\n// // Include the colors defined for your project.\n// @import 'init';\n//\n// /*\n// #{chroma-kss-markup()}\n// */\n// ```\n//\n// Then use a Gulp.js or Grunt task to strip the leading and trailing lines\n// (containing \"/*\" and \"*/\" respectively) from the generated file.\n//\n// $wrapper-class     - Defaults to 'kss-style'.\n// $title-class       - Defaults to 'chroma-kss__title'.\n// $description-class - Defaults to 'chroma-kss__description'.\n// $color-class       - Defaults to 'chroma-kss'.\n// $swatch-class      - Defaults to 'chroma-kss__swatch'.\n// $variable-class    - Defaults to 'chroma-kss__variable'.\n// $alt-text-class    - Defaults to 'chroma-kss__alt-text'.\n// $value-class       - Defaults to 'chroma-kss__value'.\n// $reference-class   - Defaults to 'chroma-kss__reference'.\n//\n// style guide: kss.chroma-kss-markup\n@function chroma-kss-markup(\n  $wrapper-class:     'kss-style',\n  $title-class:       'chroma-kss__title',\n  $description-class: 'chroma-kss__description',\n  $color-class:       'chroma-kss',\n  $swatch-class:      'chroma-kss__swatch',\n  $variable-class:    'chroma-kss__variable',\n  $alt-text-class:    'chroma-kss__alt-text',\n  $value-class:       'chroma-kss__value',\n  $reference-class:   'chroma-kss__reference'\n) {\n  $markup: '';\n\n  @each $scheme, $data in map-get($chroma, 'schemes') {\n    // Display the scheme name and description.\n    $markup: $markup\n      + '<h3 class=\"' + $title-class + '\">#{$scheme}</h3>'\n      + '<p class=\"' + $description-class + '\">#{map-get($data, 'description')}</p>';\n\n    // Display the colors in the scheme.\n    @each $color, $data in map-get($chroma, 'names') {\n      $seperator: str-index($color, '::');\n      @if $scheme == str-slice($color, 1, $seperator - 1) {\n        $color: str-slice($color, $seperator + 2);\n        $value: map-get($data, 'value');\n        $reference: map-get($data, 'reference');\n        $referenced_by: map-get($data, 'referenced_by');\n\n        // @TODO: node-sass 3.6.0 crashes with too many \"+\" operators in one command.\n        $markup: $markup\n          + '<div class=\"#{$color-class}\">'\n          +   '<span class=\"#{$swatch-class}\" style=\"background-color: #{$value}\"></span>';\n        $markup: $markup\n          +   '<code class=\"#{$variable-class}\">#{$_chroma-spelling}(#{$color})</code>'\n          +   ' <span class=\"#{$alt-text-class}\">uses the #{$_chroma-spelling}:</span> ';\n        $markup: $markup\n          +   '<span class=\"#{$value-class}\"><code>#{$value}</code>';\n        @if $reference {\n          $markup: $markup + ' (#{$reference})';\n        }\n        $markup: $markup + '</span>';\n        @if length($referenced_by) > 0 {\n          $markup: $markup + ' <span class=\"#{$reference_class}\">This #{$_chroma-spelling} is inherited by: ';\n          @for $i from 1 through length($referenced_by) {\n            $markup: $markup + nth($referenced_by, $i);\n            @if ($i != length($referenced_by)) {\n              $markup: $markup + ', ';\n            }\n          }\n          $markup: $markup + '</span>';\n        }\n        $markup: $markup + '</div>';\n      }\n    }\n  }\n\n  @if $markup and $wrapper-class {\n    $markup: '<div class=\"' + $wrapper-class + '\">' + $markup + '</div>';\n  }\n\n  $markup: '<!-- This markup is auto-generated from Sass with chroma-kss-markup(). Do not modify. -->' + $markup;\n\n  @return $markup;\n}\n\n// chroma-kss-styles()\n//\n// A mixin to add a series of rulesets that style Chroma color swatches in a KSS\n// style guide.\n//\n// Since the mixin writes CSS selectors, the mixin can be used at the root of a\n// stylesheet.\n//\n// Usage:\n// ```scss\n// // Include chroma's optional kss module.\n// @import 'chroma/kss';\n//\n// @include chroma-kss-styles();\n// ```\n//\n// $wrapper-class     - Defaults to 'kss-style'.\n// $title-class       - Defaults to 'chroma-kss__title'.\n// $description-class - Defaults to 'chroma-kss__description'.\n// $color-class       - Defaults to 'chroma-kss'.\n// $swatch-class      - Defaults to 'chroma-kss__swatch'.\n// $variable-class    - Defaults to 'chroma-kss__variable'.\n// $alt-text-class    - Defaults to 'chroma-kss__alt-text'.\n// $value-class       - Defaults to 'chroma-kss__value'.\n// $reference-class   - Defaults to 'chroma-kss__reference'.\n//\n// Style guide: kss.chroma-kss-styles\n@mixin chroma-kss-styles(\n  $wrapper-class:     'kss-style',\n  $title-class:       'chroma-kss__title',\n  $description-class: 'chroma-kss__description',\n  $color-class:       'chroma-kss',\n  $swatch-class:      'chroma-kss__swatch',\n  $variable-class:    'chroma-kss__variable',\n  $alt-text-class:    'chroma-kss__alt-text',\n  $value-class:       'chroma-kss__value',\n  $reference-class:   'chroma-kss__reference'\n) {\n  @if $wrapper-class {\n    .#{$wrapper-class} {\n      @include _chroma-kss-styles(\n        $title-class,\n        $description-class,\n        $color-class,\n        $swatch-class,\n        $variable-class,\n        $alt-text-class,\n        $value-class,\n        $reference-class\n      );\n    }\n  }\n  @else {\n    @include _chroma-kss-styles(\n      $title-class,\n      $description-class,\n      $color-class,\n      $swatch-class,\n      $variable-class,\n      $alt-text-class,\n      $value-class,\n      $reference-class\n    );\n  }\n}\n\n// _chroma-kss-styles()\n//\n// Helper mixin for chroma-kss-styles().\n//\n// No style guide reference.\n@mixin _chroma-kss-styles(\n  $title-class:       'chroma-kss__title',\n  $description-class: 'chroma-kss__description',\n  $color-class:       'chroma-kss',\n  $swatch-class:      'chroma-kss__swatch',\n  $variable-class:    'chroma-kss__variable',\n  $alt-text-class:    'chroma-kss__alt-text',\n  $value-class:       'chroma-kss__value',\n  $reference-class:   'chroma-kss__reference'\n  ) {\n\n  .#{$color-class} {\n    line-height: 50px;\n  }\n\n  .#{$swatch-class} {\n    display: inline-block;\n    width: 40px;\n    height: 40px;\n    border-radius: 40px;\n    border: 2px solid #000;\n    margin-right: 10px;\n    vertical-align: middle;\n  }\n\n  .#{$variable-class} {\n    margin-right: 10px;\n  }\n\n  .#{$alt-text-class} {\n    position: absolute !important;\n    height: 1px;\n    width: 1px;\n    overflow: hidden;\n    // IE6 and IE7 use the wrong syntax.\n    *clip: rect(1px 1px 1px 1px);\n    clip: rect(1px, 1px, 1px, 1px);\n  }\n\n  .#{$value-class} {\n    color: #bbb;\n\n    code {\n      color: #bbb;\n    }\n\n    &:before {\n      // \"\\2192\" is unicode for right arrow. \"\\ \" is a hack; otherwise space is\n      // ignored in some browsers.\n      content: '\\2192\\ ';\n      font-family: sans-serif;\n    }\n  }\n\n  .#{$reference-class} {\n    display: block;\n    position: relative;\n    top: -12px;\n    line-height: 25px;\n    padding-left: 50px;\n    color: #999;\n  }\n}\n",
		"// Compass\n//\n// Compass is an open-source CSS Authoring Framework, built on Ruby sass. The project is no longer actively maintained.\n// However the parts of the framework which were most useful and were heavily incorporated in sass by NICS in the past\n// have been ported for the newer js and c/c++ sass compilers. In these files we incorporate the functions and mixins\n// which formed the vertical rhythm module of the compass framework and make them available to the project.\n// code based on work at https://github.com/Igosuki/compass-mixins\n//\n// The vertical rhythm module contained herein can be imported using `@import 'compass/typography/vertical_rhythm'`.\n// There are a number of configurable variables which can be overridden in the init section of the sass files\n//\n// $base-font-size - The default font size for all text in pixel, default value 10px.\n// $base-line-height - The distance between text baselines (vertical rhythm) in pixels, default value 6px.\n// $rhythm-unit - The length unit in which to output rhythm values, default value 'rem'. Supported values: px, em, rem.\n// Percent units can't be used since they make calculating padding and margins impractical, and percentage borders are\n// not valid or supported in css.\n// $rem-with-px-fallback - Whether to output fallback values in px when using rem as the rhythm-unit, default value false\n// $default-rhythm-border-width - Default values for rhythm borders properties. Supports style alone eg. solid or list\n// of style and color eg. solid #aaa; default value 1px.\n// $default-rhythm-border-style - default value solid.\n// $round-to-nearest-half-line - Allows the `adjust-font-size-to` mixin and the `lines-for-font-size` function to round\n// the line height to the nearest half line height instead of the nearest integral line height to avoid large spacing\n// between lines, default value false.\n// $min-line-padding - Ensure there is at least this many pixels of vertical padding above and below the text, default value 2px.\n//\n// Style guide: init.libraries.compass\n@import 'vertical_rhythm';\n",
		"@import 'support';\n@import 'units';\n\n// The default font size for all text in pixels\n$base-font-size: 10px !default;\n\n// The distance between text baselines (vertical rhythm) in pixels.\n$base-line-height: 6px !default;\n\n// The length unit in which to output rhythm values.\n// Supported values: px, em, rem. Percent units can't be used since they\n// make calculating padding and margins impractical, and percentage borders are\n// not valid or supported in css.\n$rhythm-unit: 'rem' !default;\n\n// Whether to output fallback values in px when using rem as the rhythm-unit.\n$rem-with-px-fallback: false !default;\n\n// Default values for rhythm borders properties.\n// Supports style alone eg. `solid` or list of style and color eg. `solid #aaa`;\n$default-rhythm-border-width: 1px !default;\n$default-rhythm-border-style: solid !default;\n\n// Allows the `adjust-font-size-to` mixin and the `lines-for-font-size` function\n// to round the line height to the nearest half line height instead of the\n// nearest integral line height to avoid large spacing between lines.\n$round-to-nearest-half-line: false !default;\n\n// Ensure there is at least this many pixels\n// of vertical padding above and below the text.\n$min-line-padding: 2px !default;\n\n// The leader is the amount of whitespace in a line.\n// It might be useful in your calculations.\n$base-leader: convert-length($base-line-height - $base-font-size, $rhythm-unit, $base-font-size);\n\n// The half-leader is the amount of whitespace above and below a line.\n// It might be useful in your calculations.\n$base-half-leader: $base-leader / 2;\n\n// @private Whether the rhythm output is in absolute units (px) or not (em, rem)\n$relative-font-sizing: if($rhythm-unit == px, false, true);\n\n// Validate units\n// sass-lint:disable-all\n@if unit($base-font-size)   != 'px' { @warn \"$base-font-size must resolve to a pixel unit.\"; }\n@if unit($base-line-height) != 'px' { @warn \"$base-line-height must resolve to a pixel unit.\"; }\n@if $rhythm-unit != 'px' and $rhythm-unit != 'em' and $rhythm-unit != 'rem' {\n  @warn \"$rhythm-unit must be `px`, `em` or `rem`.\";\n} // sass-lint:enable-all\n\n// rhythm([$lines], [$font-size], [$offset])\n//\n// Calculate rhythm units.\n//\n// Weight: -1\n//\n// Style guide: init.libraries.compass.rhythm\n@function rhythm($lines: 1, $font-size: $base-font-size, $offset: 0) {\n  $rhythm: convert-length($lines * $base-line-height - $offset, $rhythm-unit, $font-size);\n  @if unit($rhythm) == px {\n    $rhythm: floor($rhythm);\n  }\n  @return $rhythm;\n}\n\n// lines-for-font-size([$font-size])\n//\n// Calculate the minimum multiple of rhythm units needed to contain the font-size.\n//\n// Weight: 0\n//\n// Style guide: init.libraries.compass.lines-for-font-size\n@function lines-for-font-size($font-size) {\n  $lines: if($round-to-nearest-half-line,\n             ceil(2 * $font-size / $base-line-height) / 2,\n             ceil($font-size / $base-line-height));\n  // If lines are cramped include some extra lead.\n  @if ($lines * $base-line-height - $font-size) < ($min-line-padding * 2) {\n    $lines: $lines + if($round-to-nearest-half-line, .5, 1);\n  }\n  @return $lines;\n}\n\n\n// @private Outputs rhythm values. For rem units, outputs pixel fallback's\n// by default.\n@mixin _output-rhythm($property, $values) {\n  @if $rhythm-unit == rem and $rem-with-px-fallback {\n    @include rem($property, $values);\n  }\n  @else {\n    $output: ();\n    @each $value in $values {\n      @if unit($value) == px {\n        // Ensure all pixel values are rounded to the nearest pixel.\n        $output: join($output, round($value));\n      }\n      @else {\n        $output: join($output, $value);\n      }\n    }\n    #{$property}: $output;\n  }\n}\n\n// establish-baseline([$font-size])\n//\n// Establishes a font baseline for the given font-size.\n//\n// Weight: 1\n//\n// Style guide: init.libraries.compass.establish-baseline\n@mixin establish-baseline($font-size: $base-font-size) {\n  $relative-size: 100% * ($font-size / $_browser-default-font-size);\n  // sass-lint:disable-all\n  @if _support-legacy-browser(ie, '6') and (not $relative-font-sizing) {\n    // IE 6 refuses to resize fonts set in pixels and it weirdly resize's fonts\n    // whose root is set in ems. So we set the root font size in percentages of\n    // the default font size, even if we are using absolute sizes elsewhere.\n    * html { font-size: $relative-size; }\n  }\n\n  html { // sass-lint:enable-all\n    font-size: if($relative-font-sizing, $relative-size, $font-size);\n\n    // Webkit has a bug that prevents line-height being set in rem on <html>;\n    // To work around this and simplify output, we can set initial line-height\n    // in ems for all relative rhythm units, even when $rhythm-unit is `rem`.\n    @if $relative-font-sizing {\n      line-height: convert-length($base-line-height, em);\n    }\n    @else {\n      line-height: round($base-line-height);\n    }\n  }\n}\n\n// reset-baseline([$font-size])\n//\n// Deprecated: Resets the baseline to 1 rhythm unit. Does not work on elements whose font-size is different from\n// `$base-font-size`. This mixin will be removed in the next release. Please use `adjust-leading-to(1)` instead.\n//\n// Weight: 2\n//\n// Style guide: init.libraries.compass.reset-baseline\n@mixin reset-baseline($font-size: $base-font-size) {\n  @include adjust-leading-to(1, $font-size);\n}\n\n// adjust-font-size-to($to-size, [$lines], [$from-size])\n//\n// Adjust a block to have a different font size and line height to maintain the rhythm. `$lines` specifies how many\n// multiples of the baseline rhythm each line of this font should use up. It does not have to be an integer, but it\n// defaults to the smallest integer that is large enough to fit the font. Use `$from-size` to adjust from a font-size\n// other than the base font-size.\n//\n// Weight: 3\n//\n// Style guide: init.libraries.compass.adjust-font-size-to\n@mixin adjust-font-size-to($to-size, $lines: null, $from-size: $base-font-size) {\n  $to-size: convert-length($to-size, px, $from-size);\n  @if $lines == auto {\n    $lines: lines-for-font-size($to-size);\n  }\n  @include _output-rhythm(font-size, convert-length($to-size, $rhythm-unit, $from-size));\n  @if $lines != null {\n    @include adjust-leading-to($lines, $to-size);\n  }\n}\n\n// adjust-leading-to($lines, [$font-size])\n//\n// Adjust a block to have different line height to maintain the rhythm. `$lines` specifies how many multiples of the\n// baseline rhythm each line of this font should use up. It does not have to be an integer, but it defaults to the\n// smallest integer that is large enough to fit the font.\n//\n// Weight: 4\n//\n// Style guide: init.libraries.compass.adjust-leading-to\n@mixin adjust-leading-to($lines, $font-size: $base-font-size) {\n  @include _output-rhythm(line-height, rhythm($lines, $font-size));\n}\n\n// leader($lines, [$font-size], [$property])\n//\n// Apply leading whitespace. The $property can be margin or padding.\n//\n// Weight: 5\n//\n// Style guide: init.libraries.compass.leader\n@mixin leader($lines: 1, $font-size: $base-font-size, $property: margin) {\n  @include _output-rhythm(#{$property}-top, rhythm($lines, $font-size));\n}\n\n// padding-leader($lines, [$font-size])\n//\n// Apply leading whitespace as padding.\n//\n// Weight: 6\n//\n// Style guide: init.libraries.compass.padding-leader\n@mixin padding-leader($lines: 1, $font-size: $base-font-size) {\n  @include _output-rhythm(padding-top, rhythm($lines, $font-size));\n}\n\n// margin-leader($lines, [$font-size])\n//\n// Apply leading whitespace as margin.\n//\n// Weight: 7\n//\n// Style guide: init.libraries.compass.margin-leader\n@mixin margin-leader($lines: 1, $font-size: $base-font-size) {\n  @include _output-rhythm(margin-top, rhythm($lines, $font-size));\n}\n\n// trailer($lines, [$font-size], [$property])\n//\n// Apply trailing whitespace. The $property can be margin or padding.\n//\n// Weight: 8\n//\n// Style guide: init.libraries.compass.trailer\n@mixin trailer($lines: 1, $font-size: $base-font-size, $property: margin) {\n  @include _output-rhythm(#{$property}-bottom, rhythm($lines, $font-size));\n}\n\n// padding-trailer($lines, [$font-size])\n//\n// Apply trailing whitespace as padding.\n//\n// Weight: 9\n//\n// Style guide: init.libraries.compass.padding-trailer\n@mixin padding-trailer($lines: 1, $font-size: $base-font-size) {\n  @include _output-rhythm(padding-bottom, rhythm($lines, $font-size));\n}\n\n// margin-trailer($lines, [$font-size])\n//\n// Apply trailing whitespace as margin.\n//\n// Weight: 10\n//\n// Style guide: init.libraries.compass.margin-trailer\n@mixin margin-trailer($lines: 1, $font-size: $base-font-size) {\n  @include _output-rhythm(margin-bottom, rhythm($lines, $font-size));\n}\n\n// rhythm([$leader], [$padding-leader], [$padding-trailer], [$trailer], [$font-size])\n//\n// Shorthand mixin to apply whitespace for top and bottom margins and padding.\n//\n// Weight: 11\n//\n// Style guide: init.libraries.compass.rhythm\n@mixin rhythm(\n  $leader: 1,\n  $padding-leader: 0,\n  $padding-trailer: $padding-leader,\n  $trailer: $leader,\n  $font-size: $base-font-size\n) {\n  @include leader($leader, $font-size);\n  @include padding-leader($padding-leader, $font-size);\n  @include padding-trailer($padding-trailer, $font-size);\n  @include trailer($trailer, $font-size);\n}\n\n// rhythm-margins([$leader], [$trailer], [$font-size])\n//\n// Shorthand mixin to apply whitespace for top and bottom margins.\n//\n// Weight: 12\n//\n// Style guide: init.libraries.compass.rhythm-margins\n@mixin rhythm-margins(\n  $leader: 1,\n  $trailer: $leader,\n  $font-size: $base-font-size\n) {\n  @include leader($leader, $font-size);\n  @include trailer($trailer, $font-size);\n}\n\n// rhythm-padding([$padding-leader], [$padding-trailer], [$font-size])\n//\n// Shorthand mixin to apply whitespace for top and bottom padding.\n//\n// Weight: 13\n//\n// Style guide: init.libraries.compass.rhythm-padding\n@mixin rhythm-padding(\n  $padding-leader: 1,\n  $padding-trailer: $padding-leader,\n  $font-size: $base-font-size\n) {\n  @include padding-leader($padding-leader, $font-size);\n  @include padding-trailer($padding-trailer, $font-size);\n}\n\n// apply-side-rhythm-border($side, [$width], [$lines], [$font-size], [$border-style])\n//\n// Apply a border and whitespace to any side without destroying the vertical rhythm. The whitespace must be greater\n// than the width of the border.\n//\n// Weight: 14\n//\n// Style guide: init.libraries.compass.apply-side-rhythm-border\n@mixin apply-side-rhythm-border(\n  $side,\n  $width: $default-rhythm-border-width,\n  $lines: 1,\n  $font-size: $base-font-size,\n  $border-style: $default-rhythm-border-style\n) {\n  // If applying borders to all sides, use shorthand properties\n  $border-prop: if($side == all, border, border-#{$side});\n  @include _output-rhythm(#{$border-prop}-width, convert-length($width, $rhythm-unit, $font-size));\n  #{$border-prop}-style: nth($border-style, 1);\n  @if type-of($border-style) == list and length($border-style) > 1 {\n    #{$border-prop}-color: nth($border-style, 2);\n  }\n  $padding-prop: if($side == all, padding, padding-#{$side});\n  @include _output-rhythm(#{$padding-prop}, rhythm($lines, $font-size, $offset: $width));\n}\n\n// leading-border([$width], [$lines], [$font-size], [$border-style])\n//\n// Apply a leading border. `$border-style` and `$width` are deprecated and will be removed in a future version of Compass.\n//\n// Weight: 15\n//\n// Style guide: init.libraries.compass.leading-border\n@mixin leading-border(\n  $width: $default-rhythm-border-width,\n  $lines: 1,\n  $font-size: $base-font-size,\n  $border-style: $default-rhythm-border-style\n) {\n  @include apply-side-rhythm-border(top, $width, $lines, $font-size, $border-style);\n}\n\n// trailing-border([$width], [$lines], [$font-size], [$border-style])\n//\n// Apply a trailing border.\n//\n// Weight: 16\n//\n// Style guide: init.libraries.compass.trailing-border\n@mixin trailing-border(\n  $width: $default-rhythm-border-width,\n  $lines: 1,\n  $font-size: $base-font-size,\n  $border-style: $default-rhythm-border-style\n) {\n  @include apply-side-rhythm-border(bottom, $width, $lines, $font-size, $border-style);\n}\n\n// horizontal-borders([$width], [$lines], [$font-size], [$border-style])\n//\n// Apply both leading and trailing borders.\n//\n// Weight: 17\n//\n// Style guide: init.libraries.compass.horizontal-borders\n@mixin horizontal-borders(\n  $width: $default-rhythm-border-width,\n  $lines: 1,\n  $font-size: $base-font-size,\n  $border-style: $default-rhythm-border-style\n) {\n  @include leading-border($width, $lines, $font-size, $border-style);\n  @include trailing-border($width, $lines, $font-size, $border-style);\n}\n\n// h-borders([$width], [$lines], [$font-size], [$border-style])\n//\n// Alias for `horizontal-borders` mixin.\n//\n// Weight: 18\n//\n// Style guide: init.libraries.compass.h-borders\n@mixin h-borders(\n  $width: $default-rhythm-border-width,\n  $lines: 1,\n  $font-size: $base-font-size,\n  $border-style: $default-rhythm-border-style\n) {\n  @include horizontal-borders($width, $lines, $font-size, $border-style);\n}\n\n// rhythm-borders([$width], [$lines], [$font-size], [$border-style])\n//\n// Apply borders and whitespace equally to all sides.\n//\n// Weight: 19\n//\n// Style guide: init.libraries.compass.rhythm-borders\n@mixin rhythm-borders(\n  $width: $default-rhythm-border-width,\n  $lines: 1,\n  $font-size: $base-font-size,\n  $border-style: $default-rhythm-border-style\n) {\n  @include apply-side-rhythm-border(all, $width, $lines, $font-size, $border-style);\n}\n",
		"// Map of compass extensions that are loaded. The value will either be\n// the version of the extension or `true` if the version is unknown.\n$compass-extensions: compass-extensions() !default;\n\n// The list of browsers you want to support.\n// Defaults to all.\n$supported-browsers: browsers() !default;\n\n// The browser usage threshold for features that gracefully degrade\n// Defaults to 1 user in 1,000.\n$graceful-usage-threshold: .1 !default;\n\n// The browser usage threshold for features that cannot degrade gracefully\n// Defaults to 1 user in 10,000.\n$critical-usage-threshold: .01 !default;\n\n// Set this to true to generate comments that will explain why a prefix was included or omitted.\n$debug-browser-support: false !default;\n\n// Minimum browser versions that must be supported.\n// The keys of this map are any valid browser according to `browsers()`.\n// The values of this map are the min version that is valid for that browser\n// according to `browser-versions($browser)`\n$browser-minimum-versions: (\n  'chrome':  null,\n  'firefox': null,\n  'ie':      null,\n  'safari':  null,\n  'opera':   null\n) !default;\n\n\n// @private\n$default-capability-options: (\n  (full-support: true),\n  (partial-support: true)\n);\n\n// When a prefix in in context, but there is no current prefix\n// That context is recorded here so other prefixes can be avoided.\n$prefix-context: null;\n\n// When a prefix is in a selector or directive scope, this is set to the\n// current prefix value.  When `null`, either there is no prefix in scope\n// or the official prefix is being rendered. The `$prefix-context`\n// variable can be used to make that distinction.\n$current-prefix: null;\n\n// When in a context that only exists in a particular version\n// this variable is set to those versions.\n$current-browser-versions: ();\n\n// The legacy support CSS 2.1 Selectors.\n// Defaults to the $critical-usage-threshold.\n$css-sel2-support-threshold: $critical-usage-threshold !default;\n\n// Check if the browser is in scope given the browser support and current prefix minimums.\n@function _browser-out-of-scope($browser, $version: null) {\n  // sass-lint:disable-all\n  @if not index($supported-browsers, $browser) {\n    @if $debug-browser-support {\n      @return '#{$browser} is not listed as a supported browser.'\n    }\n    @else {\n      @return true;\n    }\n  }\n  @else if not ($current-prefix == null or $current-prefix == browser-prefix($browser)) {\n    @if $debug-browser-support {\n      @return '#{$browser} #{$version} is incompatible with #{$current-prefix}.'\n    }\n    @else {\n      @return true;\n    }\n  } // sass-lint:enable-all\n  $current-range: map-get($current-browser-versions, $browser);\n  $current-min: if($current-range, nth($current-range, 1), null);\n  $current-max: if($current-range, nth($current-range, 2), null);\n  @if not ($version and $current-max) {\n    // We don't have any versions to compare\n    @return false;\n  }\n  @else {\n    // If the version is less than the current min, it is not supported\n    $too-old: compare-browser-versions($browser, $version, $current-min) < 0;\n    $too-new: compare-browser-versions($browser, $version, $current-max) > 0;\n    @if $too-old or $too-new {\n      @if $debug-browser-support {\n        @return 'The current scope only works with #{_display-browser-range($browser, $current-min, $current-max)}.';\n      }\n      @else {\n        @return true;\n      }\n    }\n    @else {\n      @return false;\n    }\n  }\n}\n\n// Check whether the browser is supported according to the supported browsers,\n// declared minimum support and usage thresholds.\n@function _support-legacy-browser($browser, $min-version, $max-version: null, $threshold: $critical-usage-threshold) {\n  @if not index($supported-browsers, $browser) {\n    @return false;\n  }\n  // Check agaist usage stats and declared minimums\n  $min-required-version: map-get($browser-minimum-versions, $browser);\n  $usage: if($max-version,\n             omitted-usage($browser, $min-version, $max-version),\n             omitted-usage($browser, $min-version));\n  @return $usage > $threshold or\n          ($min-required-version and\n           compare-browser-versions($browser, $max-version or $min-version, $min-required-version) >= 0);\n}\n\n// Include content for a legacy browser\n// Version can be a single version string or a list of versions ordered from oldest to newest.\n@mixin _for-legacy-browser($browser, $min-version, $max-version: $min-version,\n                          $threshold: $critical-usage-threshold,\n                          $ranges: ($browser: $min-version $max-version)) {\n  @if not _browser-out-of-scope($browser, $max-version) and\n      _support-legacy-browser($browser, $min-version, $max-version, $threshold) {\n//    @if $debug-browser-support {\n      /* Content for #{display-browser-range($browser, $min-version, $max-version)}.\n      Min version: #{map-get($browser-minimum-versions, $browser) or unspecified}.\n      User threshold to keep: #{$threshold}%. If #{display-browser-range($browser, $min-version, $max-version)} are omitted: #{omitted-usage($browser, $min-version, $max-version)}%. */\n//    }\n    @include _with-browser-ranges(_intersect-browser-ranges($current-browser-versions, $ranges)) {\n      @content;\n    }\n  }\n  //@else if $debug-browser-support and browser-out-of-scope($browser, $max-version) {\n  //  /* Content for #{display-browser-range($browser, $min-version, $max-version)} omitted.\n  //     Not allowed in the current scope: #{browser-out-of-scope($browser, $max-version)} */\n  //}\n  //@else if $debug-browser-support and not\n  //           support-legacy-browser($browser, $min-version, $max-version, $threshold) {\n  //  @if omitted-usage($browser, $min-version, $max-version) > $threshold {\n  //    /* Content for #{display-browser-range($browser, $min-version, $max-version)} omitted.\n  //       User threshold to keep: #{$threshold}%. If #{display-browser-range($browser, $min-version, $max-version)} and below are omitted: #{omitted-usage($browser, $min-version, $max-version)}%. */\n  //  } @else {\n  //    /* Content for #{display-browser-range($browser, $min-version, $max-version)} omitted.\n  //       Minimum support is #{map-get($browser-minimum-versions, $browser)}. */\n  //  }\n  //}\n}\n\n@function _display-browser-range($browser, $min-version, $max-version: $min-version) {\n  @return '#{unquote($browser)} #{unquote($min-version)}#{if($max-version != $min-version, unquote(' -') unquote($max-version), null)}';\n}\n\n\n// Renders the content once if any of the legacy browsers are supported.\n// $browsers is a map of browser name to version ranges\n@mixin _for-legacy-browsers($browsers, $threshold: $critical-usage-threshold) {\n  $rendered: false;\n  @each $browser, $range in $browsers {\n    @if not $rendered {\n      @include _for-legacy-browser($browser, $range..., $threshold: $threshold, $ranges: $browsers) {\n        $rendered: true;\n        @content;\n      }\n    }\n  }\n}\n\n// If there's a prefix context in scope, this will only output the content if the prefix matches.\n// Otherwise, sets the current prefix scope and outputs the content.\n@mixin _with-prefix($prefix) {\n  @if $current-prefix or $prefix-context {\n    @if $current-prefix == $prefix or $prefix-context == $prefix {\n      //@if $debug-browser-support {\n      //  @if $prefix {\n      //    /* content for #{$prefix} because #{$current-prefix or $prefix-context} is already in scope. */\n      //  } @else {\n      //    /* unprefixed content. #{$current-prefix or $prefix-context} is already in scope. */\n      //  }\n      //}\n      $old-prefix-context: $prefix-context;\n      $old-prefix: $current-prefix;\n      $prefix-context: $prefix-context or $current-prefix !global;\n      $current-prefix: $prefix !global;\n      @content;\n      $prefix-context: $old-prefix-context !global;\n      $current-prefix: $old-prefix !global;\n    }\n    @else if $prefix == null {\n      $old-prefix-context: $prefix-context;\n      $prefix-context: $prefix-context or $current-prefix !global;\n      $current-prefix: null !global;\n      //@if $debug-browser-support {\n      //  /* Content for official syntax. Prefix context is still #{$prefix-context}. */\n      //}\n      @content;\n      $current-prefix: $prefix-context !global;\n      $prefix-context: $old-prefix-context !global;\n    }\n    //@else if $debug-browser-support {\n    //  /* Omitting content for #{$prefix} because #{$current-prefix} is already in scope. */\n    //}\n  }\n  @else {\n    //@if $debug-browser-support and $prefix {\n    //  /* Creating new #{$prefix} context. */\n    //}\n    $prefix-context: $prefix !global;\n    $current-prefix: $prefix !global;\n    @content;\n    $current-prefix: null !global;\n    $prefix-context: null !global;\n  }\n}\n\n@function _prefixes-for-capability($capability, $threshold, $capability-options: $default-capability-options) {\n  $result: ();\n  @each $prefix in browser-prefixes($supported-browsers) {\n    $result: map-merge($result,\n                      ($prefix: _use-prefix($prefix, $capability, $threshold, $capability-options)));\n  }\n  @return $result;\n}\n\n// Yields to the mixin content once for each prefix required.\n// The current prefix is set to the $current-prefix global for use by the included content.\n// Also yields to the content once with $current-prefix set to null for the official version\n// as long as there's not already a prefix in scope.\n@mixin _with-each-prefix($capability, $threshold, $capability-options: $default-capability-options) {\n  @each $prefix, $should-use-prefix in _prefixes-for-capability($capability, $threshold, $capability-options) {\n    @if $should-use-prefix {\n      //@if $debug-browser-support and type-of($should-use-prefix) == list {\n      //  /* Capability #{$capability} is prefixed with #{$prefix} because #{$should-use-prefix} is required. */\n      //} @else if $debug-browser-support and type-of($should-use-prefix) == number {\n      //  /* Capability #{$capability} is prefixed with #{$prefix} because #{$should-use-prefix}% of users need it which is more than the threshold of #{$threshold}%. */\n      //}\n      @include _with-prefix($prefix) {\n        @include _with-browser-ranges($capability) {\n          @content;\n        }\n      }\n    }\n    //@else if $debug-browser-support {\n    //  /* Capability #{$capability} is not prefixed with #{$prefix} because #{prefix-usage($prefix, $capability, $capability-options)}% of users are affected which is less than the threshold of #{$threshold}. */\n    //}\n  }\n  @include _with-prefix(null) {\n    @include _with-browser-ranges($capability) {\n      @content;\n    }\n  }\n}\n\n// Returns true if at least one browser-version pair in $subset-ranges\n// is a higher (or same) version than the browser-version pairs in\n// $ranges.\n@function _has-browser-subset($ranges, $subset-ranges) {\n  $found-mismatch: false;\n  @each $browser, $subset-range in $subset-ranges {\n    $range: map-get($ranges, $browser);\n    @if $range {\n      $min-1: nth($subset-range, 1);\n      $max-1: nth($subset-range, 2);\n      $min-2: nth($range, 1);\n      $max-2: nth($range, 2);\n      // sass-lint:disable-all\n      @if (compare-browser-versions($browser, $min-2, $min-1) <= 0 and\n           compare-browser-versions($browser, $min-1, $max-2) <= 0) or\n          (compare-browser-versions($browser, $min-2, $max-1) <= 0 and\n           compare-browser-versions($browser, $max-1, $max-2) <= 0) or\n          (compare-browser-versions($browser, $min-1, $min-2) <= 0 and\n           compare-browser-versions($browser, $max-1, $max-2) >= 0) or\n          (compare-browser-versions($browser, $min-1, $min-2) >= 0 and\n           compare-browser-versions($browser, $max-1, $max-2) <= 0) { // sass-lint:enable-all\n        @return true;\n      }\n      @else {\n        $found-mismatch: true;\n      }\n    }\n  }\n  @return not $found-mismatch;\n}\n\n// When the same browser is in both maps, then the minimum will be set\n// to the maximum of the two minimum versions, and the maximum will be\n// set to the minmum of the two maximum versions.\n@function _intersect-browser-ranges($ranges, $new-ranges) {\n  @each $browser, $new-range in $new-ranges {\n    $old-range: map-get($ranges, $browser);\n    @if $old-range {\n      $old-min: nth($old-range, 1);\n      $old-max: if(length($old-range) == 1, $old-min, nth($old-range, 2));\n      $new-min: nth($new-range, 1);\n      $new-max: if(length($new-range) == 1, $new-min, nth($new-range, 2));\n      $maximin: if(compare-browser-versions($browser, $old-min, $new-min) > 0,\n                   $old-min, $new-min);\n      $minimax: if(compare-browser-versions($browser, $old-max, $new-max) < 0,\n                   $old-max, $new-max);\n      $ranges: map-merge($ranges, ($browser: $maximin $minimax));\n    }\n    @else {\n      $ranges: map-merge($ranges, ($browser: $new-range));\n    }\n  }\n  @return $ranges;\n}\n\n// If passed a map, that will be the new browser ranges.\n// Otherwise a range map will be created based on the given capability and prefix\n// using the `browser-ranges($capability, $prefix)` function.\n//\n// If there are current ranges in scope and the new ranges have some overlap\n// with the current,\n//\n// If there is no overlap, then the content will not be rendered.\n@mixin _with-browser-ranges($capability, $prefix: $current-prefix) {\n  $new-ranges: null;\n  @if type-of($capability) == map {\n    $new-ranges: $capability;\n  }\n  @else {\n    $new-ranges: browser-ranges($capability, $prefix);\n  }\n\n  @if _has-browser-subset($current-browser-versions, $new-ranges) {\n    $old-ranges: $current-browser-versions;\n    $current-browser-versions: _intersect-browser-ranges($old-ranges, $new-ranges) !global;\n    @content;\n    $current-browser-versions: $old-ranges !global;\n  }\n  //@else if $debug-browser-support {\n  //  /* Excluding content because #{inspect($new-ranges)} is not included within\n  //     #{inspect($current-browser-versions)} */\n  //}\n}\n\n// Returns true if the prefixed usage stats for the capability exceed the threshold\n// or if the minimum version for a supported browser would require a prefix for the capability.\n@function _use-prefix($prefix, $capability, $threshold, $capability-options: $default-capability-options) {\n  $usage: prefix-usage($prefix, $capability, $capability-options);\n  @if $usage > $threshold {\n    @return $usage;\n  }\n  @else {\n    @each $browser in browsers($prefix) {\n      @if index($supported-browsers, $browser) {\n        $min-version: map-get($browser-minimum-versions, $browser);\n        @if $min-version {\n          $actual-prefix: browser-requires-prefix($browser, $min-version, $capability, $capability-options);\n          @if $actual-prefix and $prefix == $actual-prefix {\n            @return $browser $min-version;\n          }\n        }\n      }\n    }\n  }\n  @return false;\n}\n\n@function _prefix-identifier($ident, $prefix: $current-prefix) {\n  @return unquote('#{$prefix}#{if($prefix, '-', null)}#{$ident}');\n}\n\n// Output a property and value using the current prefix.\n// It will be unprefixed if $current-prefix is null.\n@mixin _prefix-prop($property, $value, $prefix: $current-prefix) {\n  #{_prefix-identifier($property, $prefix)}: $value;\n}\n\n// Emit a set of properties with the prefix governed by the capability and usage threshold given.\n//\n// Example:\n//\n//     @include prefixed-properties(css-animation, $animation-support-threshold,\n//       (animation-name: foo, animation-duration: 2s)\n//     );\n@mixin _prefixed-properties($capability, $threshold, $properties, $capability-options: $default-capability-options) {\n  @include _with-each-prefix($capability, $threshold, $capability-options) {\n    @each $prop, $value in $properties {\n      @include _prefix-prop($prop, $value);\n    }\n  }\n}\n\n\n// @private\n@function _warn-about-old-variables() {\n  $old-variables-in-use: ();\n  @each $old-variable-name in\n        (legacy-support-for-ie, legacy-support-for-ie6, legacy-support-for-ie7,\n         legacy-support-for-ie8, legacy-support-for-mozilla, legacy-support-for-webkit,\n         experimental-support-for-mozilla, experimental-support-for-webkit,\n         experimental-support-for-opera, experimental-support-for-microsoft,\n         experimental-support-for-khtml, experimental-support-for-svg)\n  {\n    @if global-variable-exists($old-variable-name) {\n      $old-variables-in-use: append($old-variables-in-use,\n                                    unquote('$#{$old-variable-name}'), comma);\n    }\n  }\n  @if length($old-variables-in-use) > 0 {\n    // sass-lint:disable-all\n    @warn 'Compass has changed how browser support is configured. ' +\n          'The following configuration variables ' +\n          'are no longer supported: #{$old-variables-in-use}.' +\n          'Details: http://compass-style.org/help/documentation/tuning-vendor-prefixes/'\n  } // sass-lint:enable-all\n  @return $old-variables-in-use;\n}\n\n// @private\n@function _warn-about-pie-removal() {\n  @if global-variable-exists(experimental-support-for-pie) {\n    // sass-lint:disable-all\n    @warn 'Compass no longer supports css3pie.'; // sass-lint:enable-all\n  }\n  @return true;\n}\n\n// Enable browser support debugging within the content block.\n// Or you can enable it for the whole stylesheet by setting `$debug-browser-support` to true.\n@mixin _with-browser-support-debugging {\n  $current-status: $debug-browser-support;\n  $debug-browser-support: true !global;\n  @content;\n  $debug-browser-support: $current-status !global;\n}\n\n// Set a default value if the given arglist is empty\n@function _set-arglist-default($arglist, $default) {\n  $default-index: index($arglist, default);\n  @if $default-index {\n    $arglist: set-nth($arglist, $default-index, $default);\n  }\n  @return if(length($arglist) > 0, $arglist, $default);\n}\n\n\n// @private\n$_old-variable-warnings-issued: _warn-about-old-variables() !default;\n\n// @private\n$_pie-removal-warning-issued: _warn-about-pie-removal() !default;\n\n// @private\n@function _warn-about-useless-prefix-arguments($moz: null, $webkit: null, $o: null, $khtml: null, $official: null) {\n  @if $moz != null or $webkit != null or $o != null or $khtml != null or $official != null {\n    // sass-lint:disable-all\n    @warn 'Browser prefix arguments to this mixin are no longer used and ' +\n          'will be removed in the next release.';\n  }// sass-lint:enable-all\n  @return true;\n}\n\n// coerce a list to be comma delimited or make a new, empty comma delimited list.\n@function comma-list($list: ()) {\n  @return join((), $list, comma);\n}\n\n// @private Returns the legacy value for a given box-model\n// - Used by background-clip and -origin.\n@function _legacy-box($box) {\n  $box: unquote($box);\n  @if $box == padding-box { $box: padding; }\n  @if $box == border-box { $box: border; }\n  @if $box == content-box { $box: content; }\n  @return $box;\n}\n",
		"// @private Default font-size for all browsers\n$_browser-default-font-size: 16px;\n\n// Base font size in pixels, if not already defined.\n// Should be the same as the font-size of the html element.\n$base-font-size: 16px !default;\n\n// Whether to output fallback values in px when outputting rems.\n$rem-with-px-fallback: false !default;\n\n// convert-length($length, $to-unit\t[$from-context], [$to-context]\n//\n// Convert any CSS <length> or <percentage> value to any another.\n//\n// $length - A css <length> or <percentage> value\n// $to-unit - String matching a css unit keyword, e.g. 'em', '%', etc.\n// $from-context - Optional: When converting from relative units, the absolute length (in px) to which $length refers\n// (e.g. for `$length`s in em units, would normally be the font-size of the current element).\n// $to-context - Optional: For converting to relative units, the absolute length in px to which the output value will\n// refer. Defaults to the same as `$from-context`, since it is rarely needed.\n//\n// Weight: -3\n//\n// Style guide: init.libraries.compass.convert-length\n@function convert-length(\n\t$length,\n\t$to-unit,\n\t$from-context: $base-font-size,\n\t$to-context: $from-context\n) {\n\n\t$from-unit: unit($length);\n\n\t// sass-lint:disable-all\n\t// Optimize for cases where `from` and `to` units are accidentally the same.\n\t@if $from-unit == $to-unit { @return $length; }\n\n\t// Context values must be in px so we can determine a conversion ratio for\n\t// relative units.\n\t@if unit($from-context) != 'px' { @warn \"Paremeter $from-context must resolve to a value in pixel units.\"; }\n\t@if unit($to-context) != 'px' { @warn \"Parameter $to-context must resolve to a value in pixel units.\"; }\n\n\t// Convert input length to pixels\n\t$px-length: $length;\n\n\t@if $from-unit != 'px' {\n\t\t// Convert relative units using the from-context parameter.\n\t\t@if      $from-unit == 'em'  { $px-length: $length * $from-context / 1em; }\n\t\t@else if $from-unit == 'rem' { $px-length: $length * $base-font-size / 1rem; }\n\t\t@else if $from-unit == '%'   { $px-length: $length * $from-context / 100%; }\n\t\t@else if $from-unit == 'ex'  { $px-length: $length * $from-context / 2ex; }\n\t\t// Convert absolute units using Sass' conversion table.\n\t\t@else if $from-unit == 'in'  or\n\t\t\t\t\t\t $from-unit == 'mm'  or\n\t\t\t\t\t\t $from-unit == 'cm'  or\n\t\t\t\t\t\t $from-unit == 'pt'  or\n\t\t\t\t\t\t $from-unit == 'pc'  { $px-length: 0px + $length; }\n\t\t// Certain units can't be converted.\n\t\t@else if $from-unit == 'ch'  or\n\t\t\t\t\t\t $from-unit == 'vw'  or\n\t\t\t\t\t\t $from-unit == 'vh'  or\n\t\t\t\t\t\t $from-unit == 'vmin' {\n\t\t\t@warn \"#{$from-unit} units can't be reliably converted; Returning original value.\";\n\t\t\t@return $length;\n\t\t}\n\t\t@else {\n\t\t\t@warn \"#{$from-unit} is an unknown length unit. Returning original value.\";\n\t\t\t@return $length;\n\t\t}\n\t}\n\n\t// Convert length in pixels to the output unit\n\t$output-length: $px-length;\n\t@if $to-unit != 'px' {\n\t\t// Relative units\n\t\t@if      $to-unit == 'em'  { $output-length: $px-length * 1em / $to-context; }\n\t\t@else if $to-unit == 'rem' { $output-length: $px-length * 1rem / $base-font-size; }\n\t\t@else if $to-unit == '%'   { $output-length: $px-length * 100% / $to-context; }\n\t\t@else if $to-unit == 'ex'  { $output-length: $px-length * 2ex / $to-context; }\n\t\t// Absolute units\n\t\t@else if $to-unit == 'in'  { $output-length: 0in + $px-length; }\n\t\t@else if $to-unit == 'mm'  { $output-length: 0mm + $px-length; }\n\t\t@else if $to-unit == 'cm'  { $output-length: 0cm + $px-length; }\n\t\t@else if $to-unit == 'pt'  { $output-length: 0pt + $px-length; }\n\t\t@else if $to-unit == 'pc'  { $output-length: 0pc + $px-length; }\n\t\t// Non-convertible units\n\t\t@else if $to-unit == 'ch'  or\n\t\t\t\t\t\t $to-unit == 'vw'  or\n\t\t\t\t\t\t $to-unit == 'vh'  or\n\t\t\t\t\t\t $to-unit == 'vmin' {\n\t\t\t@warn \"#{$to-unit} units can't be reliably converted; Returning original value.\";\n\t\t\t@return $length;\n\t\t}\n\t\t@else {\n\t\t\t// sass-lint:disable-all\n\t\t\t@warn \"#{$to-unit} is an unknown length unit. Returning original value.\"; // sass-lint:enable-all\n\t\t\t@return $length;\n\t\t}\n\t} // sass-lint:enable-all\n\n\t@return $output-length;\n}\n\n\n// @private Get the px/rem versions of a value.\n@function _rem-fallback-values($value) {\n  $_return: (\n    px: $value,\n    rem: $value,\n  );\n\n  @if type-of($value) == number and not unitless($value) {\n    @if unit($value) == rem {\n      $_return: map-merge($_return, (\n        px: round(convert-length($value, px)),\n      ));\n    } @else if unit($value) == px {\n      $_return: map-merge($_return, (\n        px: round($value),\n        rem: convert-length($value, rem),\n      ));\n    }\n  }\n\n  @return $_return;\n}\n\n// @private Get the px/rem versions of a list (or nested lists).\n@function _list-convert-rems($value) {\n  $_empty: (\n    px: (),\n    rem: (),\n  );\n  $_return: $_empty;\n  $_sep: null;\n\n  @if type-of($value) == list {\n    $_sep: list-separator($value);\n    @each $sub in $value {\n      $_this: _list-convert-rems($sub);\n      $_return: (\n        px: append(map-get($_return, px), map-get($_this, px), $_sep),\n        rem: append(map-get($_return, rem), map-get($_this, rem), $_sep),\n      );\n    }\n  }\n\t@else {\n    $_this: _rem-fallback-values($value);\n    $_return: map-merge($_return, $_this);\n  }\n\n  @return $_return;\n}\n\n// rem($property, $values, [$use-px-fallback])\n//\n// Output a given style rule containing rem values along with an (optional) fallback rule for older browsers (with rem\n// values converted to px).\n//\n// $property - The css property name.\n// $values - The value or list of values for the property.\n// $use-px-fallback - Optional: [ true | false ]\n//\n// Weight: -2\n//\n// Style guide: init.libraries.compass.rem\n@mixin rem($property, $values, $use-px-fallback: $rem-with-px-fallback) {\n\n  // get converted values.\n  $values: _list-convert-rems($values);\n  $px-values: map-get($values, px);\n  $values: map-get($values, rem);\n\n  // Use pixel fallback for browsers that don't understand rem units.\n  @if $use-px-fallback and $px-values != $values {\n    #{$property}: $px-values;\n  }\n\n  // Use rem values for everyone else (overrides pixel values).\n  #{$property}: $values;\n}\n",
		"// headings([$from], [$to])\n//\n// Simple helper function to loop through headings h1, h2, h3, h4, h5, h6\n// The function provides an easy way to apply styles to all of the 6 standardised HTML headings (h1,h2,h3,h4,h5,h6).\n// The mixin helps effectively chop and change styling's for heading tags and save recursively writing the tags. At its\n// default state it will output all h1 to h6 tags, but is useful to apply rules to a given range of headings. You would\n// do this by calling the function: #{headings()} with the number range you need so for the example, if you wanted to\n// apply styling to your h2, h3, and h4s you would simply run: `#{headings(2,4)} {...}`\n//\n// @see <https://guwii.com/bytes/sass-function-loop-headings-h1h2h3h4h5h6/>\n//\n// $from - Optional: heading value to start from, by default is set to 1\n// $to - Optional: heading value to which to continue the loop until, by default is set to 6\n//\n// Style guide: init.functions.headings\n@function headings($_from: 1, $_to: 6) {\n  @if(_headings-valid-input($_from)) != true {\n    @error 'Variables passed to headings function must be numbers between 1 - 6';\n  }\n  @if(_headings-valid-input($_to)) != true {\n    @error 'Variables passed to headings function must be numbers between 1 - 6';\n  }\n  @if(_headings-validate-value-order($_from, $_to)) != true {\n    @error 'The $from value should be smaller than or equal to the $to value in headings function';\n  }\n  @if $_from == $_to {\n    @return 'h#{$_from}';\n  }\n  @else {\n    @return 'h#{$_from},' + headings($_from+1, $_to);\n  }\n}\n\n// headers([$from], [$to])\n//\n// Alias of headings().\n//\n// Style guide: init.functions.headers\n@function headers($_from: 1, $_to: 6) {\n  @return headings($_from, $_to);\n}\n\n// Private function to check for legitimate heading number.\n@function _headings-valid-input($_val) {\n  @return type-of($_val) == 'number' and unitless($_val) and $_val >= 1 and $_val <= 6;\n}\n\n// Private function to check that the first value is smaller than the second.\n@function _headings-validate-value-order($_val-1, $_val-2) {\n  @return $_val-2 >= $_val-1;\n}\n",
		"// strip-unit($value)\n//\n// Simple helper function to remove unit from a number type value.\n// @return {number} - unitless number.\n//\n// $value -  A variable or value to remove units from.\n//\n// Style guide: init.functions.strip-unit\n@function strip-unit($_value) {\n  @if type-of($_value) == 'number' and not unitless($_value) {\n    @return $_value / ($_value * 0 + 1);\n  }\n\n  @return $_value;\n}\n",
		"// Type checking\n//\n// A collection of functions for advanced type checking of scss values. This collection of functions is for testing if\n// the value of a variable is of a certain type. For instance, is 13rem a relative length? TRUE!\n//\n// This is likely most useful for advanced mixin creation to make the code more fault tolerant.\n//\n// @author Hugo Giraudel\n// @see <https://css-tricks.com/snippets/sass/advanced-type-checking/>\n//\n// Style guide: init.functions.type-checking\n\n// is-number($value)\n//\n// Uses the built in sass module type-of function to test if the value is of type number. Note numbers in Sass have two\n// components: the number itself, and its units. For example, in 16px the number is 16 and the unit is px.\n// Numbers can have no units, and they can have complex units. [View the documentation for more information about sass\n// numbers](https://sass-lang.com/documentation).\n//\n// $value - A variable or value to check.\n//\n// Style guide: init.functions.type-checking.is-number\n@function is-number($_value) {\n  @return type-of($_value) == 'number';\n}\n\n// is-time($value)\n//\n// Tests if a value is a number and looks for a unit of 'ms' or 's' in the submitted value.\n//\n// $value - A variable or value to check.\n//\n// Style guide: init.functions.type-checking.is-time\n@function is-time($_value) {\n  @return is-number($_value) and index('ms' 's', unit($_value)) != null;\n}\n\n// is-angle($value)\n//\n// Tests if a value is a number and looks for a unit of 'deg', 'rad', 'grad' or 'turn' in the submitted value.\n//\n// $value - A variable or value to check.\n//\n// Style guide: init.functions.type-checking.is-angle\n@function is-angle($_value) {\n  @return is-number($_value) and index('deg' 'rad' 'grad' 'turn', unit($_value)) != null;\n}\n\n// is-frequency($value)\n//\n// Tests if a value is a number and looks for a unit of 'Hz' or 'kHz' in the submitted value.\n//\n// $value - A variable or value to check.\n//\n// Style guide: init.functions.type-checking.is-frequency\n@function is-frequency($_value) {\n  @return is-number($_value) and index('Hz' 'kHz', unit($_value)) != null;\n}\n\n// is-integer($value)\n//\n// Tests if a value is a number when rounded, equals itself.\n//\n// $value - A variable or value to check.\n//\n// Style guide: init.functions.type-checking.is-integer\n@function is-integer($_value) {\n  @return is-number($_value) and round($_value) == $_value;\n}\n\n// is-relative-length($value)\n//\n// Tests if a value is a number and looks for a unit of 'em', 'ex', 'ch', 'rem', 'vw', 'vh', 'vmin' or 'vmax'\n// in the submitted value.\n//\n// $value - A variable or value to check.\n//\n// Style guide: init.functions.type-checking.is-relative-length\n@function is-relative-length($_value) {\n  @return is-number($_value) and index('em' 'ex' 'ch' 'rem' 'vw' 'vh' 'vmin' 'vmax', unit($_value)) != null;\n}\n\n// is-absolute-length($value)\n//\n// Tests if a value is a number and looks for a unit of 'cm', 'mm', 'in', 'px', 'pt' or 'pc' in the submitted value.\n//\n// $value - A variable or value to check.\n//\n// Style guide: init.functions.type-checking.is-absolute-length\n@function is-absolute-length($_value) {\n  @return is-number($_value) and index('cm' 'mm' 'in' 'px' 'pt' 'pc', unit($_value)) != null;\n}\n\n// is-percentage($value)\n//\n// Tests if a value is a number and looks for a unit of '%' in the submitted value.\n//\n// $value - A variable or value to check.\n//\n// Style guide: init.functions.type-checking.is-percentage\n@function is-percentage($_value) {\n  @return is-number($_value) and unit($_value) == '%';\n}\n\n// is-length($value)\n//\n// Tests if a value is a number and looks for a unit of 'em', 'ex', 'ch', 'rem', 'vw', 'vh', 'vmin', 'vmax','cm', 'mm',\n// 'in', 'px', 'pt' or 'pc' in the submitted value.\n//\n// $value - A variable or value to check.\n//\n// Style guide: init.functions.type-checking.is-length\n@function is-length($_value) {\n  @return is-relative-length($_value) or is-absolute-length($_value);\n}\n\n// is-resolution($value)\n//\n// Tests if a value is a number and looks for a unit of 'dpi', 'dpcm' or 'dppx' in the submitted value.\n//\n// $value - A variable or value to check.\n//\n// Style guide: init.functions.type-checking.is-resolution\n@function is-resolution($_value) {\n  @return is-number($_value) and index('dpi' 'dpcm' 'dppx', unit($_value)) != null;\n}\n\n// is-position($value)\n//\n// Tests if a value is a length or a percentage value or has a unit of 'top', 'right', 'bottom', 'left' or 'center'\n// in the submitted value.\n//\n// $value - A variable or value to check.\n//\n// Style guide: init.functions.type-checking.is-position\n@function is-position($_value) {\n  @return is-length($_value) or is-percentage($_value) or index('top' 'right' 'bottom' 'left' 'center', $_value) != null;\n}\n",
		"// sass-lint:disable no-important\n\n// visually-hidden()\n//\n// Make an element visually hidden, but accessible to screen readers, etc.\n// @see http://snook.ca/archives/html_and_css/hiding-content-for-accessibility\n//\n// Style guide: init.mixins.visually-hidden\n@mixin visually-hidden {\n  position: absolute !important;\n  height: 1px;\n  width: 1px;\n  overflow: hidden;\n  clip: rect(1px, 1px, 1px, 1px);\n  word-wrap: normal;\n}\n\n// visually-hidden--off()\n//\n// Turns off the visually-hidden effect.\n//\n// Style guide: init.mixins.visually-hidden--off\n@mixin visually-hidden--off {\n  position: static !important;\n  clip: auto;\n  height: auto;\n  width: auto;\n  overflow: visible;\n}\n\n// visually-hidden--focusable()\n//\n// Makes an element visually hidden by default, but visible when receiving\n// focus.\n//\n// Style guide: init.mixins.visually-hidden--focusable\n@mixin visually-hidden--focusable {\n  @include visually-hidden;\n\n  &:active,\n  &:focus {\n    @include visually-hidden--off;\n  }\n}\n",
		"// responsive-typo-map($map, [$breakpoints])\n//\n// A mixin to make responsive typography much more manageable.\n// @see https://www.smashingmagazine.com/2015/06/responsive-typography-with-sass-maps/\n//\n// The mixin accepts a sass map with key-value pairs with breakpoints as keys and elements for setting vertical rhythm\n// as corresponding values. The mixin checks to see whether the value of the key in the font-sizes map is a list\n// as opposed to a font-size value. If its a list, then it gets the correct value from the list by index value,\n// with the help of the nth function. It assumes that the first value is the font size, the second is the line height\n// and a third is margin values. Finally the mixin integrates with compass vertical typography mixins to output values\n// in appropriate rhythm units.\n//\n// Usage:\n// ```scss\n// $map: (null: (16px, 1.25), sml: (18px, 1.5));\n// h1 {\n//   @include responsive-typo-map($map);\n// }\n// ```\n// will generate:\n// ```css\n// h1 { font-size: 1.6rem; line-height: 1.25; }\n// @media screen and (min-width: 300px) {\n//   h1 { font-size: 1.8rem; line-height: 1.5; }\n// }\n// ```\n//\n// $map - a sass map where the key for the entry correlates to a value in the $breakpoints mapping.\n// $breakpoints - a sass map of responsive breakpoint values for a given key from the $map value. This is an optional\n// parameter which if missing will default to using a variable $grid-breakpoints if declared.\n//\n// Style guide: init.mixins.responsive-typo-map\n@mixin responsive-typo-map($fs-map, $fs-breakpoints: $grid-breakpoints) {\n  @each $fs-breakpoint, $fs-font-size in $fs-map {\n    @if $fs-breakpoint == null {\n      @include _rtp-map-attributes($fs-font-size);\n    }\n    @else {\n      // If $fs-font-size is a key that exists in\n      // $fs-breakpoints, use the value\n      @if map-has-key($fs-breakpoints, $fs-breakpoint) {\n        $fs-breakpoint: map-get($fs-breakpoints, $fs-breakpoint);\n      }\n      @media screen and (min-width: $fs-breakpoint) {\n        @include _rtp-map-attributes($fs-font-size);\n      }\n    }\n  }\n}\n\n// Private utility mixin for creating font-size, line height and margins\n@mixin _rtp-map-attributes($fs-font-size) {\n  // If $fs-font-size is a list, include\n  // both font-size, line-height and margins\n  @if type-of($fs-font-size) == 'list' {\n    @if (nth($fs-font-size, 1) != null) {\n      @include adjust-font-size-to(nth($fs-font-size, 1));\n    }\n    @if (length($fs-font-size) > 1) {\n      @if (nth($fs-font-size, 2) != null) {\n        line-height: nth($fs-font-size, 2);\n      }\n    }\n    @if (length($fs-font-size) > 2) {\n      margin: nth($fs-font-size, 3);\n    }\n  }\n  @else {\n    @include adjust-font-size-to($fs-font-size);\n  }\n}\n",
		"// Check if each $value in $values is an integer and a percentage. Convert $value to a percentage if it is an integer.\n// If all variables are valid, then return the list $new-values, if not, return false.\n@function _unity-layout-is-percentage($values) {\n  $new-values: ();\n  $new-value: 0;\n  @for $i from 1 through length($values) {\n    $value: nth($values, $i);\n\n    @if is-integer($value) {\n      @if not(is-percentage($value)) {\n        $new-value: percentage($value / 100);\n      } @else {\n        $new-value: $value;\n      }\n    } @else {\n      @return false;\n    }\n\n    $new-values: append($new-values, $new-value);\n  }\n  @return $new-values;\n}\n\n// Return true if the sum of $values is less than or equal to 100.\n@function _unity-layout-check-values-total($values) {\n  $sum: 0;\n  @each $value in $values {\n    $sum: $sum + $value;\n  }\n  @return $sum <= 100;\n}\n\n// Return true if all values are valid percentages and the sum of $values is less than or equal to 100.\n@function _unity-layout-values-valid($values) {\n  @if _unity-layout-is-percentage($values) {\n    $values: _unity-layout-is-percentage($values);\n    @if _unity-layout-check-values-total($values) {\n      @return $values;\n    } @else {\n      @error 'The sum of the values must be 100 or less';\n    }\n  } @else {\n    @error \"Included values must be an integer with an optional percentage unit value\";\n  }\n}\n\n// unity-layout($values)\n//\n// Applies main layout widths based on the list of values passed in through a sass map variable.\n//\n// Two values should be inserted for a 2 column layout and three values for a 3 column layout. The values should be\n// declared from left to right as you expect to view the layout, e.g. $values = 19%, 60%, 19% - the first value will\n// represent sidebar-first, the second value content and the third sidebar-second.\n//\n// All values must be integers or rounded percentages. The sum of the values must not exceed 100.\n//\n// $values = 19%, 60%, 19% - width values\n//\n// Style guide: init.libraries.unity-layout\n@mixin unity-layout($values) {\n  @if type-of($values) == \"list\" {\n    @if _unity-layout-values-valid($values) {\n      $values: _unity-layout-values-valid($values);\n      @if (length($values) == 2) {\n        $value-1: nth($values, 1);\n        $value-2: nth($values, 2);\n\n        // If $value-1 is less than $value-2 then it is a two column, sidebar-first layout. If $value-1 is\n        // greater than or equal to $value-2 then it is a two column, sidebar-second layout.\n        @if ($value-1 < $value-2) {\n          .content-sidebar-wrap {\n            width: 100%;\n          }\n\n          .main-content {\n            width: $value-2;\n          }\n\n          .sidebar-first-layout {\n            width: $value-1;\n          }\n        } @else {\n          .content-sidebar-wrap {\n            width: $value-1;\n          }\n\n          .main-content {\n            width: 100%;\n          }\n\n          .sidebar-second-layout {\n            width: $value-2;\n          }\n        }\n      } @else if (length($values) == 3) {\n        $value-1: nth($values, 1);\n        $value-2: nth($values, 2);\n        $value-3: nth($values, 3);\n\n        $gap: (100 - ($value-1 + $value-2 + $value-3)) / 2; // Calculate the gap width based on the input values.\n\n        $value-4: $value-1 + $value-2 + $gap; // Calculate the width of .content-sidebar-wrap.\n        $value-1: strip-unit($value-1);\n        $value-2: strip-unit($value-2);\n        $value-4: strip-unit($value-4);\n\n        // Calculate widths of $value-1 and $value-2 proportional to $value-4 and convert them to percentages\n        // with no decimals.\n        $value-1: round(percentage($value-1 / $value-4));\n        $value-2: round(percentage($value-2 / $value-4));\n\n        .content-sidebar-wrap {\n          width: $value-4 * 1%;\n        }\n\n        .main-content {\n          width: $value-2;\n        }\n\n        .sidebar-first-layout {\n          width: $value-1;\n        }\n\n        .sidebar-second-layout {\n          width: $value-3;\n        }\n      } @else {\n        @error 'Sass map variable should contain a list of either 2 or 3 values';\n      }\n    }\n  }\n  @else {\n    @error 'Sass map variable should contain a list of either 2 or 3 values';\n  }\n}\n\n"
	],
	"names": [],
	"mappings": "AyBQA,yEAAyE;AAkBzE,0EAA0E;AzBrB1E;;EAEE"
}